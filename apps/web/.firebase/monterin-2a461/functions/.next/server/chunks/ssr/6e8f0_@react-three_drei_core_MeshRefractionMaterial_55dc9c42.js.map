{"version":3,"sources":["../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/%40react-three/drei/core/MeshRefractionMaterial.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/three-mesh-bvh/src/gpu/MeshBVHUniformStruct.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/three-mesh-bvh/src/gpu/VertexAttributeTexture.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/three-mesh-bvh/src/core/Constants.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/three-mesh-bvh/src/core/utils/nodeBufferUtils.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/three-mesh-bvh/src/core/build/geometryUtils.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/three-mesh-bvh/src/core/build/computeBoundsUtils.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/three-mesh-bvh/src/core/build/splitUtils.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/three-mesh-bvh/src/core/MeshBVHNode.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/three-mesh-bvh/src/core/build/sortUtils.generated.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/three-mesh-bvh/src/core/build/sortUtils_indirect.generated.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/three-mesh-bvh/src/core/build/buildUtils.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/three-mesh-bvh/src/core/build/buildTree.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/three-mesh-bvh/src/math/SeparatingAxisBounds.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/three-mesh-bvh/src/math/MathUtilities.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/three-mesh-bvh/src/math/ExtendedTriangle.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/three-mesh-bvh/src/math/OrientedBox.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/three-mesh-bvh/src/utils/PrimitivePool.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/three-mesh-bvh/src/utils/ExtendedTrianglePool.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/three-mesh-bvh/src/core/utils/BufferStack.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/three-mesh-bvh/src/core/cast/shapecast.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/three-mesh-bvh/src/core/cast/closestPointToPoint.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/three-mesh-bvh/src/utils/ThreeRayIntersectUtilities.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/three-mesh-bvh/src/core/utils/iterationUtils.generated.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/three-mesh-bvh/src/core/cast/refit.generated.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/three-mesh-bvh/src/core/utils/intersectUtils.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/three-mesh-bvh/src/core/cast/raycast.generated.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/three-mesh-bvh/src/core/cast/raycastFirst.generated.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry.generated.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry.generated.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/three-mesh-bvh/src/core/utils/iterationUtils_indirect.generated.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/three-mesh-bvh/src/core/cast/refit_indirect.generated.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/three-mesh-bvh/src/core/cast/raycast_indirect.generated.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/three-mesh-bvh/src/core/cast/raycastFirst_indirect.generated.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry_indirect.generated.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry_indirect.generated.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/three-mesh-bvh/src/utils/BufferUtils.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/three-mesh-bvh/src/core/cast/bvhcast.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/three-mesh-bvh/src/core/MeshBVH.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/%40react-three/drei/materials/MeshRefractionMaterial.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/three-mesh-bvh/src/gpu/glsl/bvh_struct_definitions.glsl.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/three-mesh-bvh/src/gpu/glsl/bvh_distance_functions.glsl.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/three-mesh-bvh/src/gpu/glsl/common_functions.glsl.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/three-mesh-bvh/src/gpu/glsl/bvh_ray_functions.glsl.js","../../../../../../../../../Downloads/jewerly%20website/ethereal-luster/node_modules/three-mesh-bvh/src/index.js"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport { useRef, useMemo, useLayoutEffect } from 'react';\nimport { extend, useThree, useFrame } from '@react-three/fiber';\nimport { MeshBVHUniformStruct, MeshBVH, SAH } from 'three-mesh-bvh';\nimport { MeshRefractionMaterial as MeshRefractionMaterial$1 } from '../materials/MeshRefractionMaterial.js';\n\nconst isCubeTexture = def => def && def.isCubeTexture;\nfunction MeshRefractionMaterial({\n  aberrationStrength = 0,\n  fastChroma = true,\n  envMap,\n  ...props\n}) {\n  extend({\n    MeshRefractionMaterial: MeshRefractionMaterial$1\n  });\n  const material = useRef(null);\n  const {\n    size\n  } = useThree();\n  const defines = useMemo(() => {\n    var _ref, _envMap$image$;\n    const temp = {};\n    // Sampler2D and SamplerCube need different defines\n    const isCubeMap = isCubeTexture(envMap);\n    const w = (_ref = isCubeMap ? (_envMap$image$ = envMap.image[0]) == null ? void 0 : _envMap$image$.width : envMap.image.width) !== null && _ref !== void 0 ? _ref : 1024;\n    const cubeSize = w / 4;\n    const _lodMax = Math.floor(Math.log2(cubeSize));\n    const _cubeSize = Math.pow(2, _lodMax);\n    const width = 3 * Math.max(_cubeSize, 16 * 7);\n    const height = 4 * _cubeSize;\n    if (isCubeMap) temp.ENVMAP_TYPE_CUBEM = '';\n    temp.CUBEUV_TEXEL_WIDTH = `${1.0 / width}`;\n    temp.CUBEUV_TEXEL_HEIGHT = `${1.0 / height}`;\n    temp.CUBEUV_MAX_MIP = `${_lodMax}.0`;\n    // Add defines from chromatic aberration\n    if (aberrationStrength > 0) temp.CHROMATIC_ABERRATIONS = '';\n    if (fastChroma) temp.FAST_CHROMA = '';\n    return temp;\n  }, [aberrationStrength, fastChroma]);\n  useLayoutEffect(() => {\n    var _material$current;\n    // Get the geometry of this materials parent\n    const geometry = (_material$current = material.current) == null || (_material$current = _material$current.__r3f) == null || (_material$current = _material$current.parent) == null || (_material$current = _material$current.object) == null ? void 0 : _material$current.geometry;\n    // Update the BVH\n    if (geometry) {\n      material.current.bvh = new MeshBVHUniformStruct();\n      material.current.bvh.updateFrom(new MeshBVH(geometry.clone().toNonIndexed(), {\n        strategy: SAH\n      }));\n    }\n  }, []);\n  useFrame(({\n    camera\n  }) => {\n    material.current.viewMatrixInverse = camera.matrixWorld;\n    material.current.projectionMatrixInverse = camera.projectionMatrixInverse;\n  });\n  return /*#__PURE__*/React.createElement(\"meshRefractionMaterial\", _extends({\n    // @ts-ignore\n    key: JSON.stringify(defines)\n    // @ts-ignore\n    ,\n    defines: defines,\n    ref: material,\n    resolution: [size.width, size.height],\n    aberrationStrength: aberrationStrength,\n    envMap: envMap\n  }, props));\n}\n\nexport { MeshRefractionMaterial };\n","import {\n\tDataTexture,\n\tFloatType,\n\tUnsignedIntType,\n\tRGBAFormat,\n\tRGIntegerFormat,\n\tNearestFilter,\n\tBufferAttribute,\n} from 'three';\nimport {\n\tFloatVertexAttributeTexture,\n\tUIntVertexAttributeTexture,\n} from './VertexAttributeTexture.js';\nimport { BYTES_PER_NODE } from '../core/Constants.js';\nimport {\n\tBOUNDING_DATA_INDEX,\n\tCOUNT,\n\tIS_LEAF,\n\tRIGHT_NODE,\n\tOFFSET,\n\tSPLIT_AXIS,\n} from '../core/utils/nodeBufferUtils.js';\nimport { getIndexArray, getVertexCount } from '../core/build/geometryUtils.js';\n\nexport class MeshBVHUniformStruct {\n\n\tconstructor() {\n\n\t\tthis.index = new UIntVertexAttributeTexture();\n\t\tthis.position = new FloatVertexAttributeTexture();\n\t\tthis.bvhBounds = new DataTexture();\n\t\tthis.bvhContents = new DataTexture();\n\t\tthis._cachedIndexAttr = null;\n\n\t\tthis.index.overrideItemSize = 3;\n\n\t}\n\n\tupdateFrom( bvh ) {\n\n\t\tconst { geometry } = bvh;\n\t\tbvhToTextures( bvh, this.bvhBounds, this.bvhContents );\n\n\t\tthis.position.updateFrom( geometry.attributes.position );\n\n\t\t// dereference a new index attribute if we're using indirect storage\n\t\tif ( bvh.indirect ) {\n\n\t\t\tconst indirectBuffer = bvh._indirectBuffer;\n\t\t\tif (\n\t\t\t\tthis._cachedIndexAttr === null ||\n\t\t\t\tthis._cachedIndexAttr.count !== indirectBuffer.length\n\t\t\t) {\n\n\t\t\t\tif ( geometry.index ) {\n\n\t\t\t\t\tthis._cachedIndexAttr = geometry.index.clone();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst array = getIndexArray( getVertexCount( geometry ) );\n\t\t\t\t\tthis._cachedIndexAttr = new BufferAttribute( array, 1, false );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tdereferenceIndex( geometry, indirectBuffer, this._cachedIndexAttr );\n\t\t\tthis.index.updateFrom( this._cachedIndexAttr );\n\n\t\t} else {\n\n\t\t\tthis.index.updateFrom( geometry.index );\n\n\t\t}\n\n\t}\n\n\tdispose() {\n\n\t\tconst { index, position, bvhBounds, bvhContents } = this;\n\n\t\tif ( index ) index.dispose();\n\t\tif ( position ) position.dispose();\n\t\tif ( bvhBounds ) bvhBounds.dispose();\n\t\tif ( bvhContents ) bvhContents.dispose();\n\n\t}\n\n}\n\nfunction dereferenceIndex( geometry, indirectBuffer, target ) {\n\n\tconst unpacked = target.array;\n\tconst indexArray = geometry.index ? geometry.index.array : null;\n\tfor ( let i = 0, l = indirectBuffer.length; i < l; i ++ ) {\n\n\t\tconst i3 = 3 * i;\n\t\tconst v3 = 3 * indirectBuffer[ i ];\n\t\tfor ( let c = 0; c < 3; c ++ ) {\n\n\t\t\tunpacked[ i3 + c ] = indexArray ? indexArray[ v3 + c ] : v3 + c;\n\n\t\t}\n\n\t}\n\n}\n\nfunction bvhToTextures( bvh, boundsTexture, contentsTexture ) {\n\n\tconst roots = bvh._roots;\n\n\tif ( roots.length !== 1 ) {\n\n\t\tthrow new Error( 'MeshBVHUniformStruct: Multi-root BVHs not supported.' );\n\n\t}\n\n\tconst root = roots[ 0 ];\n\tconst uint16Array = new Uint16Array( root );\n\tconst uint32Array = new Uint32Array( root );\n\tconst float32Array = new Float32Array( root );\n\n\t// Both bounds need two elements per node so compute the height so it's twice as long as\n\t// the width so we can expand the row by two and still have a square texture\n\tconst nodeCount = root.byteLength / BYTES_PER_NODE;\n\tconst boundsDimension = 2 * Math.ceil( Math.sqrt( nodeCount / 2 ) );\n\tconst boundsArray = new Float32Array( 4 * boundsDimension * boundsDimension );\n\n\tconst contentsDimension = Math.ceil( Math.sqrt( nodeCount ) );\n\tconst contentsArray = new Uint32Array( 2 * contentsDimension * contentsDimension );\n\n\tfor ( let i = 0; i < nodeCount; i ++ ) {\n\n\t\tconst nodeIndex32 = i * BYTES_PER_NODE / 4;\n\t\tconst nodeIndex16 = nodeIndex32 * 2;\n\t\tconst boundsIndex = BOUNDING_DATA_INDEX( nodeIndex32 );\n\t\tfor ( let b = 0; b < 3; b ++ ) {\n\n\t\t\tboundsArray[ 8 * i + 0 + b ] = float32Array[ boundsIndex + 0 + b ];\n\t\t\tboundsArray[ 8 * i + 4 + b ] = float32Array[ boundsIndex + 3 + b ];\n\n\t\t}\n\n\t\tif ( IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\n\t\t\tconst mergedLeafCount = 0xffff0000 | count;\n\t\t\tcontentsArray[ i * 2 + 0 ] = mergedLeafCount;\n\t\t\tcontentsArray[ i * 2 + 1 ] = offset;\n\n\t\t} else {\n\n\t\t\tconst rightIndex = 4 * RIGHT_NODE( nodeIndex32, uint32Array ) / BYTES_PER_NODE;\n\t\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\n\t\t\tcontentsArray[ i * 2 + 0 ] = splitAxis;\n\t\t\tcontentsArray[ i * 2 + 1 ] = rightIndex;\n\n\t\t}\n\n\t}\n\n\tboundsTexture.image.data = boundsArray;\n\tboundsTexture.image.width = boundsDimension;\n\tboundsTexture.image.height = boundsDimension;\n\tboundsTexture.format = RGBAFormat;\n\tboundsTexture.type = FloatType;\n\tboundsTexture.internalFormat = 'RGBA32F';\n\tboundsTexture.minFilter = NearestFilter;\n\tboundsTexture.magFilter = NearestFilter;\n\tboundsTexture.generateMipmaps = false;\n\tboundsTexture.needsUpdate = true;\n\tboundsTexture.dispose();\n\n\tcontentsTexture.image.data = contentsArray;\n\tcontentsTexture.image.width = contentsDimension;\n\tcontentsTexture.image.height = contentsDimension;\n\tcontentsTexture.format = RGIntegerFormat;\n\tcontentsTexture.type = UnsignedIntType;\n\tcontentsTexture.internalFormat = 'RG32UI';\n\tcontentsTexture.minFilter = NearestFilter;\n\tcontentsTexture.magFilter = NearestFilter;\n\tcontentsTexture.generateMipmaps = false;\n\tcontentsTexture.needsUpdate = true;\n\tcontentsTexture.dispose();\n\n}\n","import {\n\tDataTexture,\n\tFloatType,\n\tIntType,\n\tUnsignedIntType,\n\tByteType,\n\tUnsignedByteType,\n\tShortType,\n\tUnsignedShortType,\n\n\tRedFormat,\n\tRGFormat,\n\tRGBAFormat,\n\n\tRedIntegerFormat,\n\tRGIntegerFormat,\n\tRGBAIntegerFormat,\n\n\tNearestFilter,\n} from 'three';\n\nfunction countToStringFormat( count ) {\n\n\tswitch ( count ) {\n\n\t\tcase 1: return 'R';\n\t\tcase 2: return 'RG';\n\t\tcase 3: return 'RGBA';\n\t\tcase 4: return 'RGBA';\n\n\t}\n\n\tthrow new Error();\n\n}\n\nfunction countToFormat( count ) {\n\n\tswitch ( count ) {\n\n\t\tcase 1: return RedFormat;\n\t\tcase 2: return RGFormat;\n\t\tcase 3: return RGBAFormat;\n\t\tcase 4: return RGBAFormat;\n\n\t}\n\n}\n\nfunction countToIntFormat( count ) {\n\n\tswitch ( count ) {\n\n\t\tcase 1: return RedIntegerFormat;\n\t\tcase 2: return RGIntegerFormat;\n\t\tcase 3: return RGBAIntegerFormat;\n\t\tcase 4: return RGBAIntegerFormat;\n\n\t}\n\n}\n\nexport class VertexAttributeTexture extends DataTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis.minFilter = NearestFilter;\n\t\tthis.magFilter = NearestFilter;\n\t\tthis.generateMipmaps = false;\n\t\tthis.overrideItemSize = null;\n\t\tthis._forcedType = null;\n\n\t}\n\n\tupdateFrom( attr ) {\n\n\t\tconst overrideItemSize = this.overrideItemSize;\n\t\tconst originalItemSize = attr.itemSize;\n\t\tconst originalCount = attr.count;\n\t\tif ( overrideItemSize !== null ) {\n\n\t\t\tif ( ( originalItemSize * originalCount ) % overrideItemSize !== 0.0 ) {\n\n\t\t\t\tthrow new Error( 'VertexAttributeTexture: overrideItemSize must divide evenly into buffer length.' );\n\n\t\t\t}\n\n\t\t\tattr.itemSize = overrideItemSize;\n\t\t\tattr.count = originalCount * originalItemSize / overrideItemSize;\n\n\t\t}\n\n\t\tconst itemSize = attr.itemSize;\n\t\tconst count = attr.count;\n\t\tconst normalized = attr.normalized;\n\t\tconst originalBufferCons = attr.array.constructor;\n\t\tconst byteCount = originalBufferCons.BYTES_PER_ELEMENT;\n\t\tlet targetType = this._forcedType;\n\t\tlet finalStride = itemSize;\n\n\t\t// derive the type of texture this should be in the shader\n\t\tif ( targetType === null ) {\n\n\t\t\tswitch ( originalBufferCons ) {\n\n\t\t\t\tcase Float32Array:\n\t\t\t\t\ttargetType = FloatType;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Uint8Array:\n\t\t\t\tcase Uint16Array:\n\t\t\t\tcase Uint32Array:\n\t\t\t\t\ttargetType = UnsignedIntType;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Int8Array:\n\t\t\t\tcase Int16Array:\n\t\t\t\tcase Int32Array:\n\t\t\t\t\ttargetType = IntType;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// get the target format to store the texture as\n\t\tlet type, format, normalizeValue, targetBufferCons;\n\t\tlet internalFormat = countToStringFormat( itemSize );\n\t\tswitch ( targetType ) {\n\n\t\t\tcase FloatType:\n\t\t\t\tnormalizeValue = 1.0;\n\t\t\t\tformat = countToFormat( itemSize );\n\n\t\t\t\tif ( normalized && byteCount === 1 ) {\n\n\t\t\t\t\ttargetBufferCons = originalBufferCons;\n\t\t\t\t\tinternalFormat += '8';\n\n\t\t\t\t\tif ( originalBufferCons === Uint8Array ) {\n\n\t\t\t\t\t\ttype = UnsignedByteType;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttype = ByteType;\n\t\t\t\t\t\tinternalFormat += '_SNORM';\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttargetBufferCons = Float32Array;\n\t\t\t\t\tinternalFormat += '32F';\n\t\t\t\t\ttype = FloatType;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase IntType:\n\t\t\t\tinternalFormat += byteCount * 8 + 'I';\n\t\t\t\tnormalizeValue = normalized ? Math.pow( 2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1 ) : 1.0;\n\t\t\t\tformat = countToIntFormat( itemSize );\n\n\t\t\t\tif ( byteCount === 1 ) {\n\n\t\t\t\t\ttargetBufferCons = Int8Array;\n\t\t\t\t\ttype = ByteType;\n\n\t\t\t\t} else if ( byteCount === 2 ) {\n\n\t\t\t\t\ttargetBufferCons = Int16Array;\n\t\t\t\t\ttype = ShortType;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttargetBufferCons = Int32Array;\n\t\t\t\t\ttype = IntType;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase UnsignedIntType:\n\t\t\t\tinternalFormat += byteCount * 8 + 'UI';\n\t\t\t\tnormalizeValue = normalized ? Math.pow( 2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1 ) : 1.0;\n\t\t\t\tformat = countToIntFormat( itemSize );\n\n\t\t\t\tif ( byteCount === 1 ) {\n\n\t\t\t\t\ttargetBufferCons = Uint8Array;\n\t\t\t\t\ttype = UnsignedByteType;\n\n\t\t\t\t} else if ( byteCount === 2 ) {\n\n\t\t\t\t\ttargetBufferCons = Uint16Array;\n\t\t\t\t\ttype = UnsignedShortType;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttargetBufferCons = Uint32Array;\n\t\t\t\t\ttype = UnsignedIntType;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\t// there will be a mismatch between format length and final length because\n\t\t// RGBFormat and RGBIntegerFormat was removed\n\t\tif ( finalStride === 3 && ( format === RGBAFormat || format === RGBAIntegerFormat ) ) {\n\n\t\t\tfinalStride = 4;\n\n\t\t}\n\n\t\t// copy the data over to the new texture array\n\t\tconst dimension = Math.ceil( Math.sqrt( count ) ) || 1;\n\t\tconst length = finalStride * dimension * dimension;\n\t\tconst dataArray = new targetBufferCons( length );\n\n\t\t// temporarily set the normalized state to false since we have custom normalization logic\n\t\tconst originalNormalized = attr.normalized;\n\t\tattr.normalized = false;\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tconst ii = finalStride * i;\n\t\t\tdataArray[ ii ] = attr.getX( i ) / normalizeValue;\n\n\t\t\tif ( itemSize >= 2 ) {\n\n\t\t\t\tdataArray[ ii + 1 ] = attr.getY( i ) / normalizeValue;\n\n\t\t\t}\n\n\t\t\tif ( itemSize >= 3 ) {\n\n\t\t\t\tdataArray[ ii + 2 ] = attr.getZ( i ) / normalizeValue;\n\n\t\t\t\tif ( finalStride === 4 ) {\n\n\t\t\t\t\tdataArray[ ii + 3 ] = 1.0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( itemSize >= 4 ) {\n\n\t\t\t\tdataArray[ ii + 3 ] = attr.getW( i ) / normalizeValue;\n\n\t\t\t}\n\n\t\t}\n\n\t\tattr.normalized = originalNormalized;\n\n\t\tthis.internalFormat = internalFormat;\n\t\tthis.format = format;\n\t\tthis.type = type;\n\t\tthis.image.width = dimension;\n\t\tthis.image.height = dimension;\n\t\tthis.image.data = dataArray;\n\t\tthis.needsUpdate = true;\n\t\tthis.dispose();\n\n\t\tattr.itemSize = originalItemSize;\n\t\tattr.count = originalCount;\n\n\t}\n\n}\n\nexport class UIntVertexAttributeTexture extends VertexAttributeTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis._forcedType = UnsignedIntType;\n\n\t}\n\n}\n\nexport class IntVertexAttributeTexture extends VertexAttributeTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis._forcedType = IntType;\n\n\t}\n\n\n}\n\nexport class FloatVertexAttributeTexture extends VertexAttributeTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis._forcedType = FloatType;\n\n\t}\n\n}\n","// Split strategy constants\nexport const CENTER = 0;\nexport const AVERAGE = 1;\nexport const SAH = 2;\n\n// Traversal constants\nexport const NOT_INTERSECTED = 0;\nexport const INTERSECTED = 1;\nexport const CONTAINED = 2;\n\n// SAH cost constants\n// TODO: hone these costs more. The relative difference between them should be the\n// difference in measured time to perform a triangle intersection vs traversing\n// bounds.\nexport const TRIANGLE_INTERSECT_COST = 1.25;\nexport const TRAVERSAL_COST = 1;\n\n\n// Build constants\nexport const BYTES_PER_NODE = 6 * 4 + 4 + 4;\nexport const IS_LEAFNODE_FLAG = 0xFFFF;\n\n// EPSILON for computing floating point error during build\n// https://en.wikipedia.org/wiki/Machine_epsilon#Values_for_standard_hardware_floating_point_arithmetics\nexport const FLOAT32_EPSILON = Math.pow( 2, - 24 );\n\nexport const SKIP_GENERATION = Symbol( 'SKIP_GENERATION' );\n","export function IS_LEAF( n16, uint16Array ) {\n\n\treturn uint16Array[ n16 + 15 ] === 0xFFFF;\n\n}\n\nexport function OFFSET( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 6 ];\n\n}\n\nexport function COUNT( n16, uint16Array ) {\n\n\treturn uint16Array[ n16 + 14 ];\n\n}\n\nexport function LEFT_NODE( n32 ) {\n\n\treturn n32 + 8;\n\n}\n\nexport function RIGHT_NODE( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 6 ];\n\n}\n\nexport function SPLIT_AXIS( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 7 ];\n\n}\n\nexport function BOUNDING_DATA_INDEX( n32 ) {\n\n\treturn n32;\n\n}\n","import { BufferAttribute } from 'three';\n\nexport function getVertexCount( geo ) {\n\n\treturn geo.index ? geo.index.count : geo.attributes.position.count;\n\n}\n\nexport function getTriCount( geo ) {\n\n\treturn getVertexCount( geo ) / 3;\n\n}\n\nexport function getIndexArray( vertexCount, BufferConstructor = ArrayBuffer ) {\n\n\tif ( vertexCount > 65535 ) {\n\n\t\treturn new Uint32Array( new BufferConstructor( 4 * vertexCount ) );\n\n\t} else {\n\n\t\treturn new Uint16Array( new BufferConstructor( 2 * vertexCount ) );\n\n\t}\n\n}\n\n// ensures that an index is present on the geometry\nexport function ensureIndex( geo, options ) {\n\n\tif ( ! geo.index ) {\n\n\t\tconst vertexCount = geo.attributes.position.count;\n\t\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\t\tconst index = getIndexArray( vertexCount, BufferConstructor );\n\t\tgeo.setIndex( new BufferAttribute( index, 1 ) );\n\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\tindex[ i ] = i;\n\n\t\t}\n\n\t}\n\n}\n\n// Computes the set of { offset, count } ranges which need independent BVH roots. Each\n// region in the geometry index that belongs to a different set of material groups requires\n// a separate BVH root, so that triangles indices belonging to one group never get swapped\n// with triangle indices belongs to another group. For example, if the groups were like this:\n//\n// [-------------------------------------------------------------]\n// |__________________|\n//   g0 = [0, 20]  |______________________||_____________________|\n//                      g1 = [16, 40]           g2 = [41, 60]\n//\n// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\nexport function getFullGeometryRange( geo, range ) {\n\n\tconst triCount = getTriCount( geo );\n\tconst drawRange = range ? range : geo.drawRange;\n\tconst start = drawRange.start / 3;\n\tconst end = ( drawRange.start + drawRange.count ) / 3;\n\n\tconst offset = Math.max( 0, start );\n\tconst count = Math.min( triCount, end ) - offset;\n\treturn [ {\n\t\toffset: Math.floor( offset ),\n\t\tcount: Math.floor( count ),\n\t} ];\n\n}\n\nexport function getRootIndexRanges( geo, range ) {\n\n\tif ( ! geo.groups || ! geo.groups.length ) {\n\n\t\treturn getFullGeometryRange( geo, range );\n\n\t}\n\n\tconst ranges = [];\n\tconst rangeBoundaries = new Set();\n\n\tconst drawRange = range ? range : geo.drawRange;\n\tconst drawRangeStart = drawRange.start / 3;\n\tconst drawRangeEnd = ( drawRange.start + drawRange.count ) / 3;\n\tfor ( const group of geo.groups ) {\n\n\t\tconst groupStart = group.start / 3;\n\t\tconst groupEnd = ( group.start + group.count ) / 3;\n\t\trangeBoundaries.add( Math.max( drawRangeStart, groupStart ) );\n\t\trangeBoundaries.add( Math.min( drawRangeEnd, groupEnd ) );\n\n\t}\n\n\n\t// note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\n\tconst sortedBoundaries = Array.from( rangeBoundaries.values() ).sort( ( a, b ) => a - b );\n\tfor ( let i = 0; i < sortedBoundaries.length - 1; i ++ ) {\n\n\t\tconst start = sortedBoundaries[ i ];\n\t\tconst end = sortedBoundaries[ i + 1 ];\n\n\t\tranges.push( {\n\t\t\toffset: Math.floor( start ),\n\t\t\tcount: Math.floor( end - start ),\n\t\t} );\n\n\t}\n\n\treturn ranges;\n\n}\n\nexport function hasGroupGaps( geometry, range ) {\n\n\tconst vertexCount = getTriCount( geometry );\n\tconst groups = getRootIndexRanges( geometry, range )\n\t\t.sort( ( a, b ) => a.offset - b.offset );\n\n\tconst finalGroup = groups[ groups.length - 1 ];\n\tfinalGroup.count = Math.min( vertexCount - finalGroup.offset, finalGroup.count );\n\n\tlet total = 0;\n\tgroups.forEach( ( { count } ) => total += count );\n\treturn vertexCount !== total;\n\n}\n","import { FLOAT32_EPSILON } from '../Constants.js';\nimport { getTriCount } from './geometryUtils.js';\n\n// computes the union of the bounds of all of the given triangles and puts the resulting box in \"target\".\n// A bounding box is computed for the centroids of the triangles, as well, and placed in \"centroidTarget\".\n// These are computed together to avoid redundant accesses to bounds array.\nexport function getBounds( triangleBounds, offset, count, target, centroidTarget ) {\n\n\tlet minx = Infinity;\n\tlet miny = Infinity;\n\tlet minz = Infinity;\n\tlet maxx = - Infinity;\n\tlet maxy = - Infinity;\n\tlet maxz = - Infinity;\n\n\tlet cminx = Infinity;\n\tlet cminy = Infinity;\n\tlet cminz = Infinity;\n\tlet cmaxx = - Infinity;\n\tlet cmaxy = - Infinity;\n\tlet cmaxz = - Infinity;\n\n\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\n\n\t\tconst cx = triangleBounds[ i + 0 ];\n\t\tconst hx = triangleBounds[ i + 1 ];\n\t\tconst lx = cx - hx;\n\t\tconst rx = cx + hx;\n\t\tif ( lx < minx ) minx = lx;\n\t\tif ( rx > maxx ) maxx = rx;\n\t\tif ( cx < cminx ) cminx = cx;\n\t\tif ( cx > cmaxx ) cmaxx = cx;\n\n\t\tconst cy = triangleBounds[ i + 2 ];\n\t\tconst hy = triangleBounds[ i + 3 ];\n\t\tconst ly = cy - hy;\n\t\tconst ry = cy + hy;\n\t\tif ( ly < miny ) miny = ly;\n\t\tif ( ry > maxy ) maxy = ry;\n\t\tif ( cy < cminy ) cminy = cy;\n\t\tif ( cy > cmaxy ) cmaxy = cy;\n\n\t\tconst cz = triangleBounds[ i + 4 ];\n\t\tconst hz = triangleBounds[ i + 5 ];\n\t\tconst lz = cz - hz;\n\t\tconst rz = cz + hz;\n\t\tif ( lz < minz ) minz = lz;\n\t\tif ( rz > maxz ) maxz = rz;\n\t\tif ( cz < cminz ) cminz = cz;\n\t\tif ( cz > cmaxz ) cmaxz = cz;\n\n\t}\n\n\ttarget[ 0 ] = minx;\n\ttarget[ 1 ] = miny;\n\ttarget[ 2 ] = minz;\n\n\ttarget[ 3 ] = maxx;\n\ttarget[ 4 ] = maxy;\n\ttarget[ 5 ] = maxz;\n\n\tcentroidTarget[ 0 ] = cminx;\n\tcentroidTarget[ 1 ] = cminy;\n\tcentroidTarget[ 2 ] = cminz;\n\n\tcentroidTarget[ 3 ] = cmaxx;\n\tcentroidTarget[ 4 ] = cmaxy;\n\tcentroidTarget[ 5 ] = cmaxz;\n\n}\n\n// precomputes the bounding box for each triangle; required for quickly calculating tree splits.\n// result is an array of size tris.length * 6 where triangle i maps to a\n// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,\n// representing the center and half-extent in each dimension of triangle i\nexport function computeTriangleBounds( geo, target = null, offset = null, count = null ) {\n\n\tconst posAttr = geo.attributes.position;\n\tconst index = geo.index ? geo.index.array : null;\n\tconst triCount = getTriCount( geo );\n\tconst normalized = posAttr.normalized;\n\tlet triangleBounds;\n\tif ( target === null ) {\n\n\t\ttriangleBounds = new Float32Array( triCount * 6 );\n\t\toffset = 0;\n\t\tcount = triCount;\n\n\t} else {\n\n\t\ttriangleBounds = target;\n\t\toffset = offset || 0;\n\t\tcount = count || triCount;\n\n\t}\n\n\t// used for non-normalized positions\n\tconst posArr = posAttr.array;\n\n\t// support for an interleaved position buffer\n\tconst bufferOffset = posAttr.offset || 0;\n\tlet stride = 3;\n\tif ( posAttr.isInterleavedBufferAttribute ) {\n\n\t\tstride = posAttr.data.stride;\n\n\t}\n\n\t// used for normalized positions\n\tconst getters = [ 'getX', 'getY', 'getZ' ];\n\n\tfor ( let tri = offset; tri < offset + count; tri ++ ) {\n\n\t\tconst tri3 = tri * 3;\n\t\tconst tri6 = tri * 6;\n\n\t\tlet ai = tri3 + 0;\n\t\tlet bi = tri3 + 1;\n\t\tlet ci = tri3 + 2;\n\n\t\tif ( index ) {\n\n\t\t\tai = index[ ai ];\n\t\t\tbi = index[ bi ];\n\t\t\tci = index[ ci ];\n\n\t\t}\n\n\t\t// we add the stride and offset here since we access the array directly\n\t\t// below for the sake of performance\n\t\tif ( ! normalized ) {\n\n\t\t\tai = ai * stride + bufferOffset;\n\t\t\tbi = bi * stride + bufferOffset;\n\t\t\tci = ci * stride + bufferOffset;\n\n\t\t}\n\n\t\tfor ( let el = 0; el < 3; el ++ ) {\n\n\t\t\tlet a, b, c;\n\n\t\t\tif ( normalized ) {\n\n\t\t\t\ta = posAttr[ getters[ el ] ]( ai );\n\t\t\t\tb = posAttr[ getters[ el ] ]( bi );\n\t\t\t\tc = posAttr[ getters[ el ] ]( ci );\n\n\t\t\t} else {\n\n\t\t\t\ta = posArr[ ai + el ];\n\t\t\t\tb = posArr[ bi + el ];\n\t\t\t\tc = posArr[ ci + el ];\n\n\t\t\t}\n\n\t\t\tlet min = a;\n\t\t\tif ( b < min ) min = b;\n\t\t\tif ( c < min ) min = c;\n\n\t\t\tlet max = a;\n\t\t\tif ( b > max ) max = b;\n\t\t\tif ( c > max ) max = c;\n\n\t\t\t// Increase the bounds size by float32 epsilon to avoid precision errors when\n\t\t\t// converting to 32 bit float. Scale the epsilon by the size of the numbers being\n\t\t\t// worked with.\n\t\t\tconst halfExtents = ( max - min ) / 2;\n\t\t\tconst el2 = el * 2;\n\t\t\ttriangleBounds[ tri6 + el2 + 0 ] = min + halfExtents;\n\t\t\ttriangleBounds[ tri6 + el2 + 1 ] = halfExtents + ( Math.abs( min ) + halfExtents ) * FLOAT32_EPSILON;\n\n\t\t}\n\n\t}\n\n\treturn triangleBounds;\n\n}\n","export function arrayToBox( nodeIndex32, array, target ) {\n\n\ttarget.min.x = array[ nodeIndex32 ];\n\ttarget.min.y = array[ nodeIndex32 + 1 ];\n\ttarget.min.z = array[ nodeIndex32 + 2 ];\n\n\ttarget.max.x = array[ nodeIndex32 + 3 ];\n\ttarget.max.y = array[ nodeIndex32 + 4 ];\n\ttarget.max.z = array[ nodeIndex32 + 5 ];\n\n\treturn target;\n\n}\n\nexport function makeEmptyBounds( target ) {\n\n\ttarget[ 0 ] = target[ 1 ] = target[ 2 ] = Infinity;\n\ttarget[ 3 ] = target[ 4 ] = target[ 5 ] = - Infinity;\n\n}\n\nexport function getLongestEdgeIndex( bounds ) {\n\n\tlet splitDimIdx = - 1;\n\tlet splitDist = - Infinity;\n\n\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\tconst dist = bounds[ i + 3 ] - bounds[ i ];\n\t\tif ( dist > splitDist ) {\n\n\t\t\tsplitDist = dist;\n\t\t\tsplitDimIdx = i;\n\n\t\t}\n\n\t}\n\n\treturn splitDimIdx;\n\n}\n\n// copies bounds a into bounds b\nexport function copyBounds( source, target ) {\n\n\ttarget.set( source );\n\n}\n\n// sets bounds target to the union of bounds a and b\nexport function unionBounds( a, b, target ) {\n\n\tlet aVal, bVal;\n\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\tconst d3 = d + 3;\n\n\t\t// set the minimum values\n\t\taVal = a[ d ];\n\t\tbVal = b[ d ];\n\t\ttarget[ d ] = aVal < bVal ? aVal : bVal;\n\n\t\t// set the max values\n\t\taVal = a[ d3 ];\n\t\tbVal = b[ d3 ];\n\t\ttarget[ d3 ] = aVal > bVal ? aVal : bVal;\n\n\t}\n\n}\n\n// expands the given bounds by the provided triangle bounds\nexport function expandByTriangleBounds( startIndex, triangleBounds, bounds ) {\n\n\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\tconst tCenter = triangleBounds[ startIndex + 2 * d ];\n\t\tconst tHalf = triangleBounds[ startIndex + 2 * d + 1 ];\n\n\t\tconst tMin = tCenter - tHalf;\n\t\tconst tMax = tCenter + tHalf;\n\n\t\tif ( tMin < bounds[ d ] ) {\n\n\t\t\tbounds[ d ] = tMin;\n\n\t\t}\n\n\t\tif ( tMax > bounds[ d + 3 ] ) {\n\n\t\t\tbounds[ d + 3 ] = tMax;\n\n\t\t}\n\n\t}\n\n}\n\n// compute bounds surface area\nexport function computeSurfaceArea( bounds ) {\n\n\tconst d0 = bounds[ 3 ] - bounds[ 0 ];\n\tconst d1 = bounds[ 4 ] - bounds[ 1 ];\n\tconst d2 = bounds[ 5 ] - bounds[ 2 ];\n\n\treturn 2 * ( d0 * d1 + d1 * d2 + d2 * d0 );\n\n}\n","import { getLongestEdgeIndex, computeSurfaceArea, copyBounds, unionBounds, expandByTriangleBounds } from '../../utils/ArrayBoxUtilities.js';\nimport { CENTER, AVERAGE, SAH, TRIANGLE_INTERSECT_COST, TRAVERSAL_COST } from '../Constants.js';\n\nconst BIN_COUNT = 32;\nconst binsSort = ( a, b ) => a.candidate - b.candidate;\nconst sahBins = new Array( BIN_COUNT ).fill().map( () => {\n\n\treturn {\n\n\t\tcount: 0,\n\t\tbounds: new Float32Array( 6 ),\n\t\trightCacheBounds: new Float32Array( 6 ),\n\t\tleftCacheBounds: new Float32Array( 6 ),\n\t\tcandidate: 0,\n\n\t};\n\n} );\nconst leftBounds = new Float32Array( 6 );\n\nexport function getOptimalSplit( nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy ) {\n\n\tlet axis = - 1;\n\tlet pos = 0;\n\n\t// Center\n\tif ( strategy === CENTER ) {\n\n\t\taxis = getLongestEdgeIndex( centroidBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = ( centroidBoundingData[ axis ] + centroidBoundingData[ axis + 3 ] ) / 2;\n\n\t\t}\n\n\t} else if ( strategy === AVERAGE ) {\n\n\t\taxis = getLongestEdgeIndex( nodeBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = getAverage( triangleBounds, offset, count, axis );\n\n\t\t}\n\n\t} else if ( strategy === SAH ) {\n\n\t\tconst rootSurfaceArea = computeSurfaceArea( nodeBoundingData );\n\t\tlet bestCost = TRIANGLE_INTERSECT_COST * count;\n\n\t\t// iterate over all axes\n\t\tconst cStart = offset * 6;\n\t\tconst cEnd = ( offset + count ) * 6;\n\t\tfor ( let a = 0; a < 3; a ++ ) {\n\n\t\t\tconst axisLeft = centroidBoundingData[ a ];\n\t\t\tconst axisRight = centroidBoundingData[ a + 3 ];\n\t\t\tconst axisLength = axisRight - axisLeft;\n\t\t\tconst binWidth = axisLength / BIN_COUNT;\n\n\t\t\t// If we have fewer triangles than we're planning to split then just check all\n\t\t\t// the triangle positions because it will be faster.\n\t\t\tif ( count < BIN_COUNT / 4 ) {\n\n\t\t\t\t// initialize the bin candidates\n\t\t\t\tconst truncatedBins = [ ...sahBins ];\n\t\t\t\ttruncatedBins.length = count;\n\n\t\t\t\t// set the candidates\n\t\t\t\tlet b = 0;\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6, b ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ b ];\n\t\t\t\t\tbin.candidate = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tbin.count = 0;\n\n\t\t\t\t\tconst {\n\t\t\t\t\t\tbounds,\n\t\t\t\t\t\tleftCacheBounds,\n\t\t\t\t\t\trightCacheBounds,\n\t\t\t\t\t} = bin;\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\trightCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\trightCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\tleftCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\tleftCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t}\n\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bounds );\n\n\t\t\t\t}\n\n\t\t\t\ttruncatedBins.sort( binsSort );\n\n\t\t\t\t// remove redundant splits\n\t\t\t\tlet splitCount = count;\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\twhile ( bi + 1 < splitCount && truncatedBins[ bi + 1 ].candidate === bin.candidate ) {\n\n\t\t\t\t\t\ttruncatedBins.splice( bi + 1, 1 );\n\t\t\t\t\t\tsplitCount --;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// find the appropriate bin for each triangle and expand the bounds.\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\tconst center = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\t\tif ( center >= bin.candidate ) {\n\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.rightCacheBounds );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.leftCacheBounds );\n\t\t\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// expand all the bounds\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\tconst leftCount = bin.count;\n\t\t\t\t\tconst rightCount = count - bin.count;\n\n\t\t\t\t\t// check the cost of this split\n\t\t\t\t\tconst leftBounds = bin.leftCacheBounds;\n\t\t\t\t\tconst rightBounds = bin.rightCacheBounds;\n\n\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet rightProb = 0;\n\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// reset the bins\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT; i ++ ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tbin.count = 0;\n\t\t\t\t\tbin.candidate = axisLeft + binWidth + i * binWidth;\n\n\t\t\t\t\tconst bounds = bin.bounds;\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// iterate over all center positions\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\tconst triCenter = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tconst relativeCenter = triCenter - axisLeft;\n\n\t\t\t\t\t// in the partition function if the centroid lies on the split plane then it is\n\t\t\t\t\t// considered to be on the right side of the split\n\t\t\t\t\tlet binIndex = ~ ~ ( relativeCenter / binWidth );\n\t\t\t\t\tif ( binIndex >= BIN_COUNT ) binIndex = BIN_COUNT - 1;\n\n\t\t\t\t\tconst bin = sahBins[ binIndex ];\n\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.bounds );\n\n\t\t\t\t}\n\n\t\t\t\t// cache the unioned bounds from right to left so we don't have to regenerate them each time\n\t\t\t\tconst lastBin = sahBins[ BIN_COUNT - 1 ];\n\t\t\t\tcopyBounds( lastBin.bounds, lastBin.rightCacheBounds );\n\t\t\t\tfor ( let i = BIN_COUNT - 2; i >= 0; i -- ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\tunionBounds( bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds );\n\n\t\t\t\t}\n\n\t\t\t\tlet leftCount = 0;\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT - 1; i ++ ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tconst binCount = bin.count;\n\t\t\t\t\tconst bounds = bin.bounds;\n\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\tconst rightBounds = nextBin.rightCacheBounds;\n\n\t\t\t\t\t// don't do anything with the bounds if the new bounds have no triangles\n\t\t\t\t\tif ( binCount !== 0 ) {\n\n\t\t\t\t\t\tif ( leftCount === 0 ) {\n\n\t\t\t\t\t\t\tcopyBounds( bounds, leftBounds );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tunionBounds( bounds, leftBounds, leftBounds );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tleftCount += binCount;\n\n\t\t\t\t\t// check the cost of this split\n\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\tlet rightProb = 0;\n\n\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst rightCount = count - leftCount;\n\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\tconsole.warn( `MeshBVH: Invalid build strategy value ${ strategy } used.` );\n\n\t}\n\n\treturn { axis, pos };\n\n}\n\n// returns the average coordinate on the specified axis of the all the provided triangles\nfunction getAverage( triangleBounds, offset, count, axis ) {\n\n\tlet avg = 0;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tavg += triangleBounds[ i * 6 + axis * 2 ];\n\n\t}\n\n\treturn avg / count;\n\n}\n","export class MeshBVHNode {\n\n\tconstructor() {\n\n\t\t// internal nodes have boundingData, left, right, and splitAxis\n\t\t// leaf nodes have offset and count (referring to primitives in the mesh geometry)\n\n\t\tthis.boundingData = new Float32Array( 6 );\n\n\t}\n\n}\n","/********************************************************/\n/* This file is generated from \"sortUtils.template.js\". */\n/********************************************************/\n// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nfunction partition( indirectBuffer, index, triangleBounds, offset, count, split ) {\n\n\tlet left = offset;\n\tlet right = offset + count - 1;\n\tconst pos = split.pos;\n\tconst axisOffset = split.axis * 2;\n\n\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n\twhile ( true ) {\n\n\t\twhile ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {\n\n\t\t\tleft ++;\n\n\t\t}\n\n\t\t// if a triangle center lies on the partition plane it is considered to be on the right side\n\t\twhile ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {\n\n\t\t\tright --;\n\n\t\t}\n\n\t\tif ( left < right ) {\n\n\t\t\t// we need to swap all of the information associated with the triangles at index\n\t\t\t// left and right; that's the verts in the geometry index, the bounds,\n\t\t\t// and perhaps the SAH planes\n\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tlet t0 = index[ left * 3 + i ];\n\t\t\t\tindex[ left * 3 + i ] = index[ right * 3 + i ];\n\t\t\t\tindex[ right * 3 + i ] = t0;\n\n\t\t\t}\n\n\n\t\t\t// swap bounds\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tlet tb = triangleBounds[ left * 6 + i ];\n\t\t\t\ttriangleBounds[ left * 6 + i ] = triangleBounds[ right * 6 + i ];\n\t\t\t\ttriangleBounds[ right * 6 + i ] = tb;\n\n\t\t\t}\n\n\t\t\tleft ++;\n\t\t\tright --;\n\n\t\t} else {\n\n\t\t\treturn left;\n\n\t\t}\n\n\t}\n\n}\n\nexport { partition };\n","/********************************************************/\n/* This file is generated from \"sortUtils.template.js\". */\n/********************************************************/\n// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nfunction partition_indirect( indirectBuffer, index, triangleBounds, offset, count, split ) {\n\n\tlet left = offset;\n\tlet right = offset + count - 1;\n\tconst pos = split.pos;\n\tconst axisOffset = split.axis * 2;\n\n\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n\twhile ( true ) {\n\n\t\twhile ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {\n\n\t\t\tleft ++;\n\n\t\t}\n\n\t\t// if a triangle center lies on the partition plane it is considered to be on the right side\n\t\twhile ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {\n\n\t\t\tright --;\n\n\t\t}\n\n\t\tif ( left < right ) {\n\n\t\t\t// we need to swap all of the information associated with the triangles at index\n\t\t\t// left and right; that's the verts in the geometry index, the bounds,\n\t\t\t// and perhaps the SAH planes\n\t\t\tlet t = indirectBuffer[ left ];\n\t\t\tindirectBuffer[ left ] = indirectBuffer[ right ];\n\t\t\tindirectBuffer[ right ] = t;\n\n\n\t\t\t// swap bounds\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tlet tb = triangleBounds[ left * 6 + i ];\n\t\t\t\ttriangleBounds[ left * 6 + i ] = triangleBounds[ right * 6 + i ];\n\t\t\t\ttriangleBounds[ right * 6 + i ] = tb;\n\n\t\t\t}\n\n\t\t\tleft ++;\n\t\t\tright --;\n\n\t\t} else {\n\n\t\t\treturn left;\n\n\t\t}\n\n\t}\n\n}\n\nexport { partition_indirect };\n","import { BYTES_PER_NODE, IS_LEAFNODE_FLAG } from '../Constants.js';\nimport { IS_LEAF } from '../utils/nodeBufferUtils.js';\n\nlet float32Array, uint32Array, uint16Array, uint8Array;\nconst MAX_POINTER = Math.pow( 2, 32 );\n\nexport function countNodes( node ) {\n\n\tif ( 'count' in node ) {\n\n\t\treturn 1;\n\n\t} else {\n\n\t\treturn 1 + countNodes( node.left ) + countNodes( node.right );\n\n\t}\n\n}\n\nexport function populateBuffer( byteOffset, node, buffer ) {\n\n\tfloat32Array = new Float32Array( buffer );\n\tuint32Array = new Uint32Array( buffer );\n\tuint16Array = new Uint16Array( buffer );\n\tuint8Array = new Uint8Array( buffer );\n\n\treturn _populateBuffer( byteOffset, node );\n\n}\n\n// pack structure\n// boundingData  \t\t\t\t: 6 float32\n// right / offset \t\t\t\t: 1 uint32\n// splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\nfunction _populateBuffer( byteOffset, node ) {\n\n\tconst stride4Offset = byteOffset / 4;\n\tconst stride2Offset = byteOffset / 2;\n\tconst isLeaf = 'count' in node;\n\tconst boundingData = node.boundingData;\n\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\tfloat32Array[ stride4Offset + i ] = boundingData[ i ];\n\n\t}\n\n\tif ( isLeaf ) {\n\n\t\tif ( node.buffer ) {\n\n\t\t\tconst buffer = node.buffer;\n\t\t\tuint8Array.set( new Uint8Array( buffer ), byteOffset );\n\n\t\t\tfor ( let offset = byteOffset, l = byteOffset + buffer.byteLength; offset < l; offset += BYTES_PER_NODE ) {\n\n\t\t\t\tconst offset2 = offset / 2;\n\t\t\t\tif ( ! IS_LEAF( offset2, uint16Array ) ) {\n\n\t\t\t\t\tuint32Array[ ( offset / 4 ) + 6 ] += stride4Offset;\n\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn byteOffset + buffer.byteLength;\n\n\t\t} else {\n\n\t\t\tconst offset = node.offset;\n\t\t\tconst count = node.count;\n\t\t\tuint32Array[ stride4Offset + 6 ] = offset;\n\t\t\tuint16Array[ stride2Offset + 14 ] = count;\n\t\t\tuint16Array[ stride2Offset + 15 ] = IS_LEAFNODE_FLAG;\n\t\t\treturn byteOffset + BYTES_PER_NODE;\n\n\t\t}\n\n\t} else {\n\n\t\tconst left = node.left;\n\t\tconst right = node.right;\n\t\tconst splitAxis = node.splitAxis;\n\n\t\tlet nextUnusedPointer;\n\t\tnextUnusedPointer = _populateBuffer( byteOffset + BYTES_PER_NODE, left );\n\n\t\tif ( ( nextUnusedPointer / 4 ) > MAX_POINTER ) {\n\n\t\t\tthrow new Error( 'MeshBVH: Cannot store child pointer greater than 32 bits.' );\n\n\t\t}\n\n\t\tuint32Array[ stride4Offset + 6 ] = nextUnusedPointer / 4;\n\t\tnextUnusedPointer = _populateBuffer( nextUnusedPointer, right );\n\n\t\tuint32Array[ stride4Offset + 7 ] = splitAxis;\n\t\treturn nextUnusedPointer;\n\n\t}\n\n}\n","import { ensureIndex, getFullGeometryRange, getRootIndexRanges, getTriCount, hasGroupGaps, } from './geometryUtils.js';\nimport { getBounds, computeTriangleBounds } from './computeBoundsUtils.js';\nimport { getOptimalSplit } from './splitUtils.js';\nimport { MeshBVHNode } from '../MeshBVHNode.js';\nimport { BYTES_PER_NODE } from '../Constants.js';\n\nimport { partition } from './sortUtils.generated.js';\nimport { partition_indirect } from './sortUtils_indirect.generated.js';\nimport { countNodes, populateBuffer } from './buildUtils.js';\n\nexport function generateIndirectBuffer( geometry, useSharedArrayBuffer ) {\n\n\tconst triCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\n\tconst useUint32 = triCount > 2 ** 16;\n\tconst byteCount = useUint32 ? 4 : 2;\n\n\tconst buffer = useSharedArrayBuffer ? new SharedArrayBuffer( triCount * byteCount ) : new ArrayBuffer( triCount * byteCount );\n\tconst indirectBuffer = useUint32 ? new Uint32Array( buffer ) : new Uint16Array( buffer );\n\tfor ( let i = 0, l = indirectBuffer.length; i < l; i ++ ) {\n\n\t\tindirectBuffer[ i ] = i;\n\n\t}\n\n\treturn indirectBuffer;\n\n}\n\nexport function buildTree( bvh, triangleBounds, offset, count, options ) {\n\n\t// epxand variables\n\tconst {\n\t\tmaxDepth,\n\t\tverbose,\n\t\tmaxLeafTris,\n\t\tstrategy,\n\t\tonProgress,\n\t\tindirect,\n\t} = options;\n\tconst indirectBuffer = bvh._indirectBuffer;\n\tconst geometry = bvh.geometry;\n\tconst indexArray = geometry.index ? geometry.index.array : null;\n\tconst partionFunc = indirect ? partition_indirect : partition;\n\n\t// generate intermediate variables\n\tconst totalTriangles = getTriCount( geometry );\n\tconst cacheCentroidBoundingData = new Float32Array( 6 );\n\tlet reachedMaxDepth = false;\n\n\tconst root = new MeshBVHNode();\n\tgetBounds( triangleBounds, offset, count, root.boundingData, cacheCentroidBoundingData );\n\tsplitNode( root, offset, count, cacheCentroidBoundingData );\n\treturn root;\n\n\tfunction triggerProgress( trianglesProcessed ) {\n\n\t\tif ( onProgress ) {\n\n\t\t\tonProgress( trianglesProcessed / totalTriangles );\n\n\t\t}\n\n\t}\n\n\t// either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\n\t// recording the offset and count of its triangles and writing them into the reordered geometry index.\n\tfunction splitNode( node, offset, count, centroidBoundingData = null, depth = 0 ) {\n\n\t\tif ( ! reachedMaxDepth && depth >= maxDepth ) {\n\n\t\t\treachedMaxDepth = true;\n\t\t\tif ( verbose ) {\n\n\t\t\t\tconsole.warn( `MeshBVH: Max depth of ${ maxDepth } reached when generating BVH. Consider increasing maxDepth.` );\n\t\t\t\tconsole.warn( geometry );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// early out if we've met our capacity\n\t\tif ( count <= maxLeafTris || depth >= maxDepth ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\t// Find where to split the volume\n\t\tconst split = getOptimalSplit( node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy );\n\t\tif ( split.axis === - 1 ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\tconst splitOffset = partionFunc( indirectBuffer, indexArray, triangleBounds, offset, count, split );\n\n\t\t// create the two new child nodes\n\t\tif ( splitOffset === offset || splitOffset === offset + count ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\n\t\t} else {\n\n\t\t\tnode.splitAxis = split.axis;\n\n\t\t\t// create the left child and compute its bounding box\n\t\t\tconst left = new MeshBVHNode();\n\t\t\tconst lstart = offset;\n\t\t\tconst lcount = splitOffset - offset;\n\t\t\tnode.left = left;\n\n\t\t\tgetBounds( triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( left, lstart, lcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t\t// repeat for right\n\t\t\tconst right = new MeshBVHNode();\n\t\t\tconst rstart = splitOffset;\n\t\t\tconst rcount = count - lcount;\n\t\t\tnode.right = right;\n\n\t\t\tgetBounds( triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( right, rstart, rcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n}\n\nexport function buildPackedTree( bvh, options ) {\n\n\tconst geometry = bvh.geometry;\n\tif ( options.indirect ) {\n\n\t\tbvh._indirectBuffer = generateIndirectBuffer( geometry, options.useSharedArrayBuffer );\n\n\t\tif ( hasGroupGaps( geometry, options.range ) && ! options.verbose ) {\n\n\t\t\tconsole.warn(\n\t\t\t\t'MeshBVH: Provided geometry contains groups or a range that do not fully span the vertex contents while using the \"indirect\" option. ' +\n\t\t\t\t'BVH may incorrectly report intersections on unrendered portions of the geometry.'\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\tif ( ! bvh._indirectBuffer ) {\n\n\t\tensureIndex( geometry, options );\n\n\t}\n\n\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\n\tconst triangleBounds = computeTriangleBounds( geometry );\n\tconst geometryRanges = options.indirect ? getFullGeometryRange( geometry, options.range ) : getRootIndexRanges( geometry, options.range );\n\tbvh._roots = geometryRanges.map( range => {\n\n\t\tconst root = buildTree( bvh, triangleBounds, range.offset, range.count, options );\n\t\tconst nodeCount = countNodes( root );\n\t\tconst buffer = new BufferConstructor( BYTES_PER_NODE * nodeCount );\n\t\tpopulateBuffer( 0, root, buffer );\n\t\treturn buffer;\n\n\t} );\n\n}\n","import { Vector3 } from 'three';\n\nexport class SeparatingAxisBounds {\n\n\tconstructor() {\n\n\t\tthis.min = Infinity;\n\t\tthis.max = - Infinity;\n\n\t}\n\n\tsetFromPointsField( points, field ) {\n\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tconst val = p[ field ];\n\t\t\tmin = val < min ? val : min;\n\t\t\tmax = val > max ? val : max;\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tsetFromPoints( axis, points ) {\n\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tconst val = axis.dot( p );\n\t\t\tmin = val < min ? val : min;\n\t\t\tmax = val > max ? val : max;\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tisSeparated( other ) {\n\n\t\treturn this.min > other.max || other.min > this.max;\n\n\t}\n\n}\n\nSeparatingAxisBounds.prototype.setFromBox = ( function () {\n\n\tconst p = new Vector3();\n\treturn function setFromBox( axis, box ) {\n\n\t\tconst boxMin = box.min;\n\t\tconst boxMax = box.max;\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tp.x = boxMin.x * x + boxMax.x * ( 1 - x );\n\t\t\t\t\tp.y = boxMin.y * y + boxMax.y * ( 1 - y );\n\t\t\t\t\tp.z = boxMin.z * z + boxMax.z * ( 1 - z );\n\n\t\t\t\t\tconst val = axis.dot( p );\n\t\t\t\t\tmin = Math.min( val, min );\n\t\t\t\t\tmax = Math.max( val, max );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t};\n\n} )();\n\nexport const areIntersecting = ( function () {\n\n\tconst cacheSatBounds = new SeparatingAxisBounds();\n\treturn function areIntersecting( shape1, shape2 ) {\n\n\t\tconst points1 = shape1.points;\n\t\tconst satAxes1 = shape1.satAxes;\n\t\tconst satBounds1 = shape1.satBounds;\n\n\t\tconst points2 = shape2.points;\n\t\tconst satAxes2 = shape2.satAxes;\n\t\tconst satBounds2 = shape2.satBounds;\n\n\t\t// check axes of the first shape\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds1[ i ];\n\t\t\tconst sa = satAxes1[ i ];\n\t\t\tcacheSatBounds.setFromPoints( sa, points2 );\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\n\n\t\t}\n\n\t\t// check axes of the second shape\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds2[ i ];\n\t\t\tconst sa = satAxes2[ i ];\n\t\t\tcacheSatBounds.setFromPoints( sa, points1 );\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\n\n\t\t}\n\n\t};\n\n} )();\n","import { Vector3, Vector2, Plane, Line3 } from 'three';\n\nexport const closestPointLineToLine = ( function () {\n\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/Line.cpp#L56\n\tconst dir1 = new Vector3();\n\tconst dir2 = new Vector3();\n\tconst v02 = new Vector3();\n\treturn function closestPointLineToLine( l1, l2, result ) {\n\n\t\tconst v0 = l1.start;\n\t\tconst v10 = dir1;\n\t\tconst v2 = l2.start;\n\t\tconst v32 = dir2;\n\n\t\tv02.subVectors( v0, v2 );\n\t\tdir1.subVectors( l1.end, l1.start );\n\t\tdir2.subVectors( l2.end, l2.start );\n\n\t\t// float d0232 = v02.Dot(v32);\n\t\tconst d0232 = v02.dot( v32 );\n\n\t\t// float d3210 = v32.Dot(v10);\n\t\tconst d3210 = v32.dot( v10 );\n\n\t\t// float d3232 = v32.Dot(v32);\n\t\tconst d3232 = v32.dot( v32 );\n\n\t\t// float d0210 = v02.Dot(v10);\n\t\tconst d0210 = v02.dot( v10 );\n\n\t\t// float d1010 = v10.Dot(v10);\n\t\tconst d1010 = v10.dot( v10 );\n\n\t\t// float denom = d1010*d3232 - d3210*d3210;\n\t\tconst denom = d1010 * d3232 - d3210 * d3210;\n\n\t\tlet d, d2;\n\t\tif ( denom !== 0 ) {\n\n\t\t\td = ( d0232 * d3210 - d0210 * d3232 ) / denom;\n\n\t\t} else {\n\n\t\t\td = 0;\n\n\t\t}\n\n\t\td2 = ( d0232 + d * d3210 ) / d3232;\n\n\t\tresult.x = d;\n\t\tresult.y = d2;\n\n\t};\n\n} )();\n\nexport const closestPointsSegmentToSegment = ( function () {\n\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/LineSegment.cpp#L187\n\tconst paramResult = new Vector2();\n\tconst temp1 = new Vector3();\n\tconst temp2 = new Vector3();\n\treturn function closestPointsSegmentToSegment( l1, l2, target1, target2 ) {\n\n\t\tclosestPointLineToLine( l1, l2, paramResult );\n\n\t\tlet d = paramResult.x;\n\t\tlet d2 = paramResult.y;\n\t\tif ( d >= 0 && d <= 1 && d2 >= 0 && d2 <= 1 ) {\n\n\t\t\tl1.at( d, target1 );\n\t\t\tl2.at( d2, target2 );\n\n\t\t\treturn;\n\n\t\t} else if ( d >= 0 && d <= 1 ) {\n\n\t\t\t// Only d2 is out of bounds.\n\t\t\tif ( d2 < 0 ) {\n\n\t\t\t\tl2.at( 0, target2 );\n\n\t\t\t} else {\n\n\t\t\t\tl2.at( 1, target2 );\n\n\t\t\t}\n\n\t\t\tl1.closestPointToPoint( target2, true, target1 );\n\t\t\treturn;\n\n\t\t} else if ( d2 >= 0 && d2 <= 1 ) {\n\n\t\t\t// Only d is out of bounds.\n\t\t\tif ( d < 0 ) {\n\n\t\t\t\tl1.at( 0, target1 );\n\n\t\t\t} else {\n\n\t\t\t\tl1.at( 1, target1 );\n\n\t\t\t}\n\n\t\t\tl2.closestPointToPoint( target1, true, target2 );\n\t\t\treturn;\n\n\t\t} else {\n\n\t\t\t// Both u and u2 are out of bounds.\n\t\t\tlet p;\n\t\t\tif ( d < 0 ) {\n\n\t\t\t\tp = l1.start;\n\n\t\t\t} else {\n\n\t\t\t\tp = l1.end;\n\n\t\t\t}\n\n\t\t\tlet p2;\n\t\t\tif ( d2 < 0 ) {\n\n\t\t\t\tp2 = l2.start;\n\n\t\t\t} else {\n\n\t\t\t\tp2 = l2.end;\n\n\t\t\t}\n\n\t\t\tconst closestPoint = temp1;\n\t\t\tconst closestPoint2 = temp2;\n\t\t\tl1.closestPointToPoint( p2, true, temp1 );\n\t\t\tl2.closestPointToPoint( p, true, temp2 );\n\n\t\t\tif ( closestPoint.distanceToSquared( p2 ) <= closestPoint2.distanceToSquared( p ) ) {\n\n\t\t\t\ttarget1.copy( closestPoint );\n\t\t\t\ttarget2.copy( p2 );\n\t\t\t\treturn;\n\n\t\t\t} else {\n\n\t\t\t\ttarget1.copy( p );\n\t\t\t\ttarget2.copy( closestPoint2 );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n} )();\n\n\nexport const sphereIntersectTriangle = ( function () {\n\n\t// https://stackoverflow.com/questions/34043955/detect-collision-between-sphere-and-triangle-in-three-js\n\tconst closestPointTemp = new Vector3();\n\tconst projectedPointTemp = new Vector3();\n\tconst planeTemp = new Plane();\n\tconst lineTemp = new Line3();\n\treturn function sphereIntersectTriangle( sphere, triangle ) {\n\n\t\tconst { radius, center } = sphere;\n\t\tconst { a, b, c } = triangle;\n\n\t\t// phase 1\n\t\tlineTemp.start = a;\n\t\tlineTemp.end = b;\n\t\tconst closestPoint1 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint1.distanceTo( center ) <= radius ) return true;\n\n\t\tlineTemp.start = a;\n\t\tlineTemp.end = c;\n\t\tconst closestPoint2 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint2.distanceTo( center ) <= radius ) return true;\n\n\t\tlineTemp.start = b;\n\t\tlineTemp.end = c;\n\t\tconst closestPoint3 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint3.distanceTo( center ) <= radius ) return true;\n\n\t\t// phase 2\n\t\tconst plane = triangle.getPlane( planeTemp );\n\t\tconst dp = Math.abs( plane.distanceToPoint( center ) );\n\t\tif ( dp <= radius ) {\n\n\t\t\tconst pp = plane.projectPoint( center, projectedPointTemp );\n\t\t\tconst cp = triangle.containsPoint( pp );\n\t\t\tif ( cp ) return true;\n\n\t\t}\n\n\t\treturn false;\n\n\t};\n\n} )();\n","import { Triangle, Vector3, Line3, Sphere, Plane } from 'three';\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\nimport { closestPointsSegmentToSegment, sphereIntersectTriangle } from './MathUtilities.js';\n\nconst ZERO_EPSILON = 1e-15;\nfunction isNearZero( value ) {\n\n\treturn Math.abs( value ) < ZERO_EPSILON;\n\n}\n\nexport class ExtendedTriangle extends Triangle {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tthis.isExtendedTriangle = true;\n\t\tthis.satAxes = new Array( 4 ).fill().map( () => new Vector3() );\n\t\tthis.satBounds = new Array( 4 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.points = [ this.a, this.b, this.c ];\n\t\tthis.sphere = new Sphere();\n\t\tthis.plane = new Plane();\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn sphereIntersectTriangle( sphere, this );\n\n\t}\n\n\tupdate() {\n\n\t\tconst a = this.a;\n\t\tconst b = this.b;\n\t\tconst c = this.c;\n\t\tconst points = this.points;\n\n\t\tconst satAxes = this.satAxes;\n\t\tconst satBounds = this.satBounds;\n\n\t\tconst axis0 = satAxes[ 0 ];\n\t\tconst sab0 = satBounds[ 0 ];\n\t\tthis.getNormal( axis0 );\n\t\tsab0.setFromPoints( axis0, points );\n\n\t\tconst axis1 = satAxes[ 1 ];\n\t\tconst sab1 = satBounds[ 1 ];\n\t\taxis1.subVectors( a, b );\n\t\tsab1.setFromPoints( axis1, points );\n\n\t\tconst axis2 = satAxes[ 2 ];\n\t\tconst sab2 = satBounds[ 2 ];\n\t\taxis2.subVectors( b, c );\n\t\tsab2.setFromPoints( axis2, points );\n\n\t\tconst axis3 = satAxes[ 3 ];\n\t\tconst sab3 = satBounds[ 3 ];\n\t\taxis3.subVectors( c, a );\n\t\tsab3.setFromPoints( axis3, points );\n\n\t\tthis.sphere.setFromPoints( this.points );\n\t\tthis.plane.setFromNormalAndCoplanarPoint( axis0, a );\n\t\tthis.needsUpdate = false;\n\n\t}\n\n}\n\nExtendedTriangle.prototype.closestPointToSegment = ( function () {\n\n\tconst point1 = new Vector3();\n\tconst point2 = new Vector3();\n\tconst edge = new Line3();\n\n\treturn function distanceToSegment( segment, target1 = null, target2 = null ) {\n\n\t\tconst { start, end } = segment;\n\t\tconst points = this.points;\n\t\tlet distSq;\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check the triangle edges\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst nexti = ( i + 1 ) % 3;\n\t\t\tedge.start.copy( points[ i ] );\n\t\t\tedge.end.copy( points[ nexti ] );\n\n\t\t\tclosestPointsSegmentToSegment( edge, segment, point1, point2 );\n\n\t\t\tdistSq = point1.distanceToSquared( point2 );\n\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check end points\n\t\tthis.closestPointToPoint( start, point1 );\n\t\tdistSq = start.distanceToSquared( point1 );\n\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\tclosestDistanceSq = distSq;\n\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\tif ( target2 ) target2.copy( start );\n\n\t\t}\n\n\t\tthis.closestPointToPoint( end, point1 );\n\t\tdistSq = end.distanceToSquared( point1 );\n\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\tclosestDistanceSq = distSq;\n\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\tif ( target2 ) target2.copy( end );\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n\nExtendedTriangle.prototype.intersectsTriangle = ( function () {\n\n\tconst saTri2 = new ExtendedTriangle();\n\tconst arr1 = new Array( 3 );\n\tconst arr2 = new Array( 3 );\n\tconst cachedSatBounds = new SeparatingAxisBounds();\n\tconst cachedSatBounds2 = new SeparatingAxisBounds();\n\tconst cachedAxis = new Vector3();\n\tconst dir = new Vector3();\n\tconst dir1 = new Vector3();\n\tconst dir2 = new Vector3();\n\tconst tempDir = new Vector3();\n\tconst edge = new Line3();\n\tconst edge1 = new Line3();\n\tconst edge2 = new Line3();\n\tconst tempPoint = new Vector3();\n\n\tfunction triIntersectPlane( tri, plane, targetEdge ) {\n\n\t\t// find the edge that intersects the other triangle plane\n\t\tconst points = tri.points;\n\t\tlet count = 0;\n\t\tlet startPointIntersection = - 1;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst { start, end } = edge;\n\t\t\tstart.copy( points[ i ] );\n\t\t\tend.copy( points[ ( i + 1 ) % 3 ] );\n\t\t\tedge.delta( dir );\n\n\t\t\tconst startIntersects = isNearZero( plane.distanceToPoint( start ) );\n\t\t\tif ( isNearZero( plane.normal.dot( dir ) ) && startIntersects ) {\n\n\t\t\t\t// if the edge lies on the plane then take the line\n\t\t\t\ttargetEdge.copy( edge );\n\t\t\t\tcount = 2;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// check if the start point is near the plane because \"intersectLine\" is not robust to that case\n\t\t\tconst doesIntersect = plane.intersectLine( edge, tempPoint );\n\t\t\tif ( ! doesIntersect && startIntersects ) {\n\n\t\t\t\ttempPoint.copy( start );\n\n\t\t\t}\n\n\t\t\t// ignore the end point\n\t\t\tif ( ( doesIntersect || startIntersects ) && ! isNearZero( tempPoint.distanceTo( end ) ) ) {\n\n\t\t\t\tif ( count <= 1 ) {\n\n\t\t\t\t\t// assign to the start or end point and save which index was snapped to\n\t\t\t\t\t// the start point if necessary\n\t\t\t\t\tconst point = count === 1 ? targetEdge.start : targetEdge.end;\n\t\t\t\t\tpoint.copy( tempPoint );\n\t\t\t\t\tif ( startIntersects ) {\n\n\t\t\t\t\t\tstartPointIntersection = count;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( count >= 2 ) {\n\n\t\t\t\t\t// if we're here that means that there must have been one point that had\n\t\t\t\t\t// snapped to the start point so replace it here\n\t\t\t\t\tconst point = startPointIntersection === 1 ? targetEdge.start : targetEdge.end;\n\t\t\t\t\tpoint.copy( tempPoint );\n\t\t\t\t\tcount = 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tcount ++;\n\t\t\t\tif ( count === 2 && startPointIntersection === - 1 ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn count;\n\n\t}\n\n\t// TODO: If the triangles are coplanar and intersecting the target is nonsensical. It should at least\n\t// be a line contained by both triangles if not a different special case somehow represented in the return result.\n\treturn function intersectsTriangle( other, target = null, suppressLog = false ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( ! other.isExtendedTriangle ) {\n\n\t\t\tsaTri2.copy( other );\n\t\t\tsaTri2.update();\n\t\t\tother = saTri2;\n\n\t\t} else if ( other.needsUpdate ) {\n\n\t\t\tother.update();\n\n\t\t}\n\n\t\tconst plane1 = this.plane;\n\t\tconst plane2 = other.plane;\n\n\t\tif ( Math.abs( plane1.normal.dot( plane2.normal ) ) > 1.0 - 1e-10 ) {\n\n\t\t\t// perform separating axis intersection test only for coplanar triangles\n\t\t\tconst satBounds1 = this.satBounds;\n\t\t\tconst satAxes1 = this.satAxes;\n\t\t\tarr2[ 0 ] = other.a;\n\t\t\tarr2[ 1 ] = other.b;\n\t\t\tarr2[ 2 ] = other.c;\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst sb = satBounds1[ i ];\n\t\t\t\tconst sa = satAxes1[ i ];\n\t\t\t\tcachedSatBounds.setFromPoints( sa, arr2 );\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\tconst satBounds2 = other.satBounds;\n\t\t\tconst satAxes2 = other.satAxes;\n\t\t\tarr1[ 0 ] = this.a;\n\t\t\tarr1[ 1 ] = this.b;\n\t\t\tarr1[ 2 ] = this.c;\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst sb = satBounds2[ i ];\n\t\t\t\tconst sa = satAxes2[ i ];\n\t\t\t\tcachedSatBounds.setFromPoints( sa, arr1 );\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\t// check crossed axes\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst sa1 = satAxes1[ i ];\n\t\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\n\n\t\t\t\t\tconst sa2 = satAxes2[ i2 ];\n\t\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\n\t\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, arr1 );\n\t\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, arr2 );\n\t\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( target ) {\n\n\t\t\t\t// TODO find two points that intersect on the edges and make that the result\n\t\t\t\tif ( ! suppressLog ) {\n\n\t\t\t\t\tconsole.warn( 'ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.' );\n\n\t\t\t\t}\n\n\t\t\t\ttarget.start.set( 0, 0, 0 );\n\t\t\t\ttarget.end.set( 0, 0, 0 );\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\t// find the edge that intersects the other triangle plane\n\t\t\tconst count1 = triIntersectPlane( this, plane2, edge1 );\n\t\t\tif ( count1 === 1 && other.containsPoint( edge1.end ) ) {\n\n\t\t\t\tif ( target ) {\n\n\t\t\t\t\ttarget.start.copy( edge1.end );\n\t\t\t\t\ttarget.end.copy( edge1.end );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t} else if ( count1 !== 2 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// find the other triangles edge that intersects this plane\n\t\t\tconst count2 = triIntersectPlane( other, plane1, edge2 );\n\t\t\tif ( count2 === 1 && this.containsPoint( edge2.end ) ) {\n\n\t\t\t\tif ( target ) {\n\n\t\t\t\t\ttarget.start.copy( edge2.end );\n\t\t\t\t\ttarget.end.copy( edge2.end );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t} else if ( count2 !== 2 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// find swap the second edge so both lines are running the same direction\n\t\t\tedge1.delta( dir1 );\n\t\t\tedge2.delta( dir2 );\n\n\t\t\tif ( dir1.dot( dir2 ) < 0 ) {\n\n\t\t\t\tlet tmp = edge2.start;\n\t\t\t\tedge2.start = edge2.end;\n\t\t\t\tedge2.end = tmp;\n\n\t\t\t}\n\n\t\t\t// check if the edges are overlapping\n\t\t\tconst s1 = edge1.start.dot( dir1 );\n\t\t\tconst e1 = edge1.end.dot( dir1 );\n\t\t\tconst s2 = edge2.start.dot( dir1 );\n\t\t\tconst e2 = edge2.end.dot( dir1 );\n\t\t\tconst separated1 = e1 < s2;\n\t\t\tconst separated2 = s1 < e2;\n\n\t\t\tif ( s1 !== e2 && s2 !== e1 && separated1 === separated2 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// assign the target output\n\t\t\tif ( target ) {\n\n\t\t\t\ttempDir.subVectors( edge1.start, edge2.start );\n\t\t\t\tif ( tempDir.dot( dir1 ) > 0 ) {\n\n\t\t\t\t\ttarget.start.copy( edge1.start );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttarget.start.copy( edge2.start );\n\n\t\t\t\t}\n\n\t\t\t\ttempDir.subVectors( edge1.end, edge2.end );\n\t\t\t\tif ( tempDir.dot( dir1 ) < 0 ) {\n\n\t\t\t\t\ttarget.end.copy( edge1.end );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttarget.end.copy( edge2.end );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t};\n\n} )();\n\n\nExtendedTriangle.prototype.distanceToPoint = ( function () {\n\n\tconst target = new Vector3();\n\treturn function distanceToPoint( point ) {\n\n\t\tthis.closestPointToPoint( point, target );\n\t\treturn point.distanceTo( target );\n\n\t};\n\n} )();\n\n\nExtendedTriangle.prototype.distanceToTriangle = ( function () {\n\n\tconst point = new Vector3();\n\tconst point2 = new Vector3();\n\tconst cornerFields = [ 'a', 'b', 'c' ];\n\tconst line1 = new Line3();\n\tconst line2 = new Line3();\n\n\treturn function distanceToTriangle( other, target1 = null, target2 = null ) {\n\n\t\tconst lineTarget = target1 || target2 ? line1 : null;\n\t\tif ( this.intersectsTriangle( other, lineTarget ) ) {\n\n\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\tif ( target1 ) lineTarget.getCenter( target1 );\n\t\t\t\tif ( target2 ) lineTarget.getCenter( target2 );\n\n\t\t\t}\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check all point distances\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tlet dist;\n\t\t\tconst field = cornerFields[ i ];\n\t\t\tconst otherVec = other[ field ];\n\t\t\tthis.closestPointToPoint( otherVec, point );\n\n\t\t\tdist = otherVec.distanceToSquared( point );\n\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( point );\n\t\t\t\tif ( target2 ) target2.copy( otherVec );\n\n\t\t\t}\n\n\n\t\t\tconst thisVec = this[ field ];\n\t\t\tother.closestPointToPoint( thisVec, point );\n\n\t\t\tdist = thisVec.distanceToSquared( point );\n\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( thisVec );\n\t\t\t\tif ( target2 ) target2.copy( point );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst f11 = cornerFields[ i ];\n\t\t\tconst f12 = cornerFields[ ( i + 1 ) % 3 ];\n\t\t\tline1.set( this[ f11 ], this[ f12 ] );\n\t\t\tfor ( let i2 = 0; i2 < 3; i2 ++ ) {\n\n\t\t\t\tconst f21 = cornerFields[ i2 ];\n\t\t\t\tconst f22 = cornerFields[ ( i2 + 1 ) % 3 ];\n\t\t\t\tline2.set( other[ f21 ], other[ f22 ] );\n\n\t\t\t\tclosestPointsSegmentToSegment( line1, line2, point, point2 );\n\n\t\t\t\tconst dist = point.distanceToSquared( point2 );\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( point );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n","import { Vector3, Matrix4, Line3 } from 'three';\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\nimport { ExtendedTriangle } from './ExtendedTriangle.js';\nimport { closestPointsSegmentToSegment } from './MathUtilities.js';\n\nexport class OrientedBox {\n\n\tconstructor( min, max, matrix ) {\n\n\t\tthis.isOrientedBox = true;\n\t\tthis.min = new Vector3();\n\t\tthis.max = new Vector3();\n\t\tthis.matrix = new Matrix4();\n\t\tthis.invMatrix = new Matrix4();\n\t\tthis.points = new Array( 8 ).fill().map( () => new Vector3() );\n\t\tthis.satAxes = new Array( 3 ).fill().map( () => new Vector3() );\n\t\tthis.satBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.alignedSatBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.needsUpdate = false;\n\n\t\tif ( min ) this.min.copy( min );\n\t\tif ( max ) this.max.copy( max );\n\t\tif ( matrix ) this.matrix.copy( matrix );\n\n\t}\n\n\tset( min, max, matrix ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\t\tthis.matrix.copy( matrix );\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tcopy( other ) {\n\n\t\tthis.min.copy( other.min );\n\t\tthis.max.copy( other.max );\n\t\tthis.matrix.copy( other.matrix );\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n\nOrientedBox.prototype.update = ( function () {\n\n\treturn function update() {\n\n\t\tconst matrix = this.matrix;\n\t\tconst min = this.min;\n\t\tconst max = this.max;\n\n\t\tconst points = this.points;\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tconst i = ( ( 1 << 0 ) * x ) | ( ( 1 << 1 ) * y ) | ( ( 1 << 2 ) * z );\n\t\t\t\t\tconst v = points[ i ];\n\t\t\t\t\tv.x = x ? max.x : min.x;\n\t\t\t\t\tv.y = y ? max.y : min.y;\n\t\t\t\t\tv.z = z ? max.z : min.z;\n\n\t\t\t\t\tv.applyMatrix4( matrix );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\t\tconst minVec = points[ 0 ];\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst axis = satAxes[ i ];\n\t\t\tconst sb = satBounds[ i ];\n\t\t\tconst index = 1 << i;\n\t\t\tconst pi = points[ index ];\n\n\t\t\taxis.subVectors( minVec, pi );\n\t\t\tsb.setFromPoints( axis, points );\n\n\t\t}\n\n\t\tconst alignedSatBounds = this.alignedSatBounds;\n\t\talignedSatBounds[ 0 ].setFromPointsField( points, 'x' );\n\t\talignedSatBounds[ 1 ].setFromPointsField( points, 'y' );\n\t\talignedSatBounds[ 2 ].setFromPointsField( points, 'z' );\n\n\t\tthis.invMatrix.copy( this.matrix ).invert();\n\t\tthis.needsUpdate = false;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.intersectsBox = ( function () {\n\n\tconst aabbBounds = new SeparatingAxisBounds();\n\treturn function intersectsBox( box ) {\n\n\t\t// TODO: should this be doing SAT against the AABB?\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tconst min = box.min;\n\t\tconst max = box.max;\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\t\tconst alignedSatBounds = this.alignedSatBounds;\n\n\t\taabbBounds.min = min.x;\n\t\taabbBounds.max = max.x;\n\t\tif ( alignedSatBounds[ 0 ].isSeparated( aabbBounds ) ) return false;\n\n\t\taabbBounds.min = min.y;\n\t\taabbBounds.max = max.y;\n\t\tif ( alignedSatBounds[ 1 ].isSeparated( aabbBounds ) ) return false;\n\n\t\taabbBounds.min = min.z;\n\t\taabbBounds.max = max.z;\n\t\tif ( alignedSatBounds[ 2 ].isSeparated( aabbBounds ) ) return false;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst axis = satAxes[ i ];\n\t\t\tconst sb = satBounds[ i ];\n\t\t\taabbBounds.setFromBox( axis, box );\n\t\t\tif ( sb.isSeparated( aabbBounds ) ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.intersectsTriangle = ( function () {\n\n\tconst saTri = new ExtendedTriangle();\n\tconst pointsArr = new Array( 3 );\n\tconst cachedSatBounds = new SeparatingAxisBounds();\n\tconst cachedSatBounds2 = new SeparatingAxisBounds();\n\tconst cachedAxis = new Vector3();\n\treturn function intersectsTriangle( triangle ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( ! triangle.isExtendedTriangle ) {\n\n\t\t\tsaTri.copy( triangle );\n\t\t\tsaTri.update();\n\t\t\ttriangle = saTri;\n\n\t\t} else if ( triangle.needsUpdate ) {\n\n\t\t\ttriangle.update();\n\n\t\t}\n\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\n\t\tpointsArr[ 0 ] = triangle.a;\n\t\tpointsArr[ 1 ] = triangle.b;\n\t\tpointsArr[ 2 ] = triangle.c;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds[ i ];\n\t\t\tconst sa = satAxes[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, pointsArr );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t}\n\n\t\tconst triSatBounds = triangle.satBounds;\n\t\tconst triSatAxes = triangle.satAxes;\n\t\tconst points = this.points;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = triSatBounds[ i ];\n\t\t\tconst sa = triSatAxes[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, points );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t}\n\n\t\t// check crossed axes\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sa1 = satAxes[ i ];\n\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\n\n\t\t\t\tconst sa2 = triSatAxes[ i2 ];\n\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\n\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, pointsArr );\n\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, points );\n\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.closestPointToPoint = ( function () {\n\n\treturn function closestPointToPoint( point, target1 ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\ttarget1\n\t\t\t.copy( point )\n\t\t\t.applyMatrix4( this.invMatrix )\n\t\t\t.clamp( this.min, this.max )\n\t\t\t.applyMatrix4( this.matrix );\n\n\t\treturn target1;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.distanceToPoint = ( function () {\n\n\tconst target = new Vector3();\n\treturn function distanceToPoint( point ) {\n\n\t\tthis.closestPointToPoint( point, target );\n\t\treturn point.distanceTo( target );\n\n\t};\n\n} )();\n\nOrientedBox.prototype.distanceToBox = ( function () {\n\n\tconst xyzFields = [ 'x', 'y', 'z' ];\n\tconst segments1 = new Array( 12 ).fill().map( () => new Line3() );\n\tconst segments2 = new Array( 12 ).fill().map( () => new Line3() );\n\n\tconst point1 = new Vector3();\n\tconst point2 = new Vector3();\n\n\t// early out if we find a value below threshold\n\treturn function distanceToBox( box, threshold = 0, target1 = null, target2 = null ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( this.intersectsBox( box ) ) {\n\n\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\tbox.getCenter( point2 );\n\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\tbox.closestPointToPoint( point1, point2 );\n\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t}\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tconst threshold2 = threshold * threshold;\n\t\tconst min = box.min;\n\t\tconst max = box.max;\n\t\tconst points = this.points;\n\n\n\t\t// iterate over every edge and compare distances\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check over all these points\n\t\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tpoint2.copy( p ).clamp( min, max );\n\n\t\t\tconst dist = p.distanceToSquared( point2 );\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( p );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate and check all line segment distances\n\t\tlet count = 0;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tfor ( let i1 = 0; i1 <= 1; i1 ++ ) {\n\n\t\t\t\tfor ( let i2 = 0; i2 <= 1; i2 ++ ) {\n\n\t\t\t\t\tconst nextIndex = ( i + 1 ) % 3;\n\t\t\t\t\tconst nextIndex2 = ( i + 2 ) % 3;\n\n\t\t\t\t\t// get obb line segments\n\t\t\t\t\tconst index = i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\tconst index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\tconst p1 = points[ index ];\n\t\t\t\t\tconst p2 = points[ index2 ];\n\t\t\t\t\tconst line1 = segments1[ count ];\n\t\t\t\t\tline1.set( p1, p2 );\n\n\n\t\t\t\t\t// get aabb line segments\n\t\t\t\t\tconst f1 = xyzFields[ i ];\n\t\t\t\t\tconst f2 = xyzFields[ nextIndex ];\n\t\t\t\t\tconst f3 = xyzFields[ nextIndex2 ];\n\t\t\t\t\tconst line2 = segments2[ count ];\n\t\t\t\t\tconst start = line2.start;\n\t\t\t\t\tconst end = line2.end;\n\n\t\t\t\t\tstart[ f1 ] = min[ f1 ];\n\t\t\t\t\tstart[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\tstart[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\tend[ f1 ] = max[ f1 ];\n\t\t\t\t\tend[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\tend[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\tcount ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check all the other boxes point\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tpoint2.x = x ? max.x : min.x;\n\t\t\t\t\tpoint2.y = y ? max.y : min.y;\n\t\t\t\t\tpoint2.z = z ? max.z : min.z;\n\n\t\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\t\tconst dist = point2.distanceToSquared( point1 );\n\t\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 12; i ++ ) {\n\n\t\t\tconst l1 = segments1[ i ];\n\t\t\tfor ( let i2 = 0; i2 < 12; i2 ++ ) {\n\n\t\t\t\tconst l2 = segments2[ i2 ];\n\t\t\t\tclosestPointsSegmentToSegment( l1, l2, point1, point2 );\n\t\t\t\tconst dist = point1.distanceToSquared( point2 );\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n","export class PrimitivePool {\n\n\tconstructor( getNewPrimitive ) {\n\n\t\tthis._getNewPrimitive = getNewPrimitive;\n\t\tthis._primitives = [];\n\n\t}\n\n\tgetPrimitive() {\n\n\t\tconst primitives = this._primitives;\n\t\tif ( primitives.length === 0 ) {\n\n\t\t\treturn this._getNewPrimitive();\n\n\t\t} else {\n\n\t\t\treturn primitives.pop();\n\n\t\t}\n\n\t}\n\n\treleasePrimitive( primitive ) {\n\n\t\tthis._primitives.push( primitive );\n\n\t}\n\n}\n","import { ExtendedTriangle } from '../math/ExtendedTriangle.js';\nimport { PrimitivePool } from './PrimitivePool.js';\n\nclass ExtendedTrianglePoolBase extends PrimitivePool {\n\n\tconstructor() {\n\n\t\tsuper( () => new ExtendedTriangle() );\n\n\t}\n\n}\n\nexport const ExtendedTrianglePool = /* @__PURE__ */ new ExtendedTrianglePoolBase();\n","class _BufferStack {\n\n\tconstructor() {\n\n\t\tthis.float32Array = null;\n\t\tthis.uint16Array = null;\n\t\tthis.uint32Array = null;\n\n\t\tconst stack = [];\n\t\tlet prevBuffer = null;\n\t\tthis.setBuffer = buffer => {\n\n\t\t\tif ( prevBuffer ) {\n\n\t\t\t\tstack.push( prevBuffer );\n\n\t\t\t}\n\n\t\t\tprevBuffer = buffer;\n\t\t\tthis.float32Array = new Float32Array( buffer );\n\t\t\tthis.uint16Array = new Uint16Array( buffer );\n\t\t\tthis.uint32Array = new Uint32Array( buffer );\n\n\t\t};\n\n\t\tthis.clearBuffer = () => {\n\n\t\t\tprevBuffer = null;\n\t\t\tthis.float32Array = null;\n\t\t\tthis.uint16Array = null;\n\t\t\tthis.uint32Array = null;\n\n\t\t\tif ( stack.length !== 0 ) {\n\n\t\t\t\tthis.setBuffer( stack.pop() );\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n}\n\nexport const BufferStack = new _BufferStack();\n","import { Box3 } from 'three';\nimport { CONTAINED } from '../Constants.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { PrimitivePool } from '../../utils/PrimitivePool.js';\nimport { COUNT, OFFSET, LEFT_NODE, RIGHT_NODE, IS_LEAF, BOUNDING_DATA_INDEX } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\n\nlet _box1, _box2;\nconst boxStack = [];\nconst boxPool = /* @__PURE__ */ new PrimitivePool( () => new Box3() );\n\nexport function shapecast( bvh, root, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset ) {\n\n\t// setup\n\t_box1 = boxPool.getPrimitive();\n\t_box2 = boxPool.getPrimitive();\n\tboxStack.push( _box1, _box2 );\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\n\tconst result = shapecastTraverse( 0, bvh.geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\n\n\t// cleanup\n\tBufferStack.clearBuffer();\n\tboxPool.releasePrimitive( _box1 );\n\tboxPool.releasePrimitive( _box2 );\n\tboxStack.pop();\n\tboxStack.pop();\n\n\tconst length = boxStack.length;\n\tif ( length > 0 ) {\n\n\t\t_box2 = boxStack[ length - 1 ];\n\t\t_box1 = boxStack[ length - 2 ];\n\n\t}\n\n\treturn result;\n\n}\n\nfunction shapecastTraverse(\n\tnodeIndex32,\n\tgeometry,\n\tintersectsBoundsFunc,\n\tintersectsRangeFunc,\n\tnodeScoreFunc = null,\n\tnodeIndexByteOffset = 0, // offset for unique node identifier\n\tdepth = 0\n) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, _box1 );\n\t\treturn intersectsRangeFunc( offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box1 );\n\n\t} else {\n\n\t\tconst left = LEFT_NODE( nodeIndex32 );\n\t\tconst right = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tlet c1 = left;\n\t\tlet c2 = right;\n\n\t\tlet score1, score2;\n\t\tlet box1, box2;\n\t\tif ( nodeScoreFunc ) {\n\n\t\t\tbox1 = _box1;\n\t\t\tbox2 = _box2;\n\n\t\t\t// bounding data is not offset\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\t\tscore1 = nodeScoreFunc( box1 );\n\t\t\tscore2 = nodeScoreFunc( box2 );\n\n\t\t\tif ( score2 < score1 ) {\n\n\t\t\t\tc1 = right;\n\t\t\t\tc2 = left;\n\n\t\t\t\tconst temp = score1;\n\t\t\t\tscore1 = score2;\n\t\t\t\tscore2 = temp;\n\n\t\t\t\tbox1 = box2;\n\t\t\t\t// box2 is always set before use below\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Check box 1 intersection\n\t\tif ( ! box1 ) {\n\n\t\t\tbox1 = _box1;\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\n\t\t}\n\n\t\tconst isC1Leaf = IS_LEAF( c1 * 2, uint16Array );\n\t\tconst c1Intersection = intersectsBoundsFunc( box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1 );\n\n\t\tlet c1StopTraversal;\n\t\tif ( c1Intersection === CONTAINED ) {\n\n\t\t\tconst offset = getLeftOffset( c1 );\n\t\t\tconst end = getRightEndOffset( c1 );\n\t\t\tconst count = end - offset;\n\n\t\t\tc1StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c1, box1 );\n\n\t\t} else {\n\n\t\t\tc1StopTraversal =\n\t\t\t\tc1Intersection &&\n\t\t\t\tshapecastTraverse(\n\t\t\t\t\tc1,\n\t\t\t\t\tgeometry,\n\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\tdepth + 1\n\t\t\t\t);\n\n\t\t}\n\n\t\tif ( c1StopTraversal ) return true;\n\n\t\t// Check box 2 intersection\n\t\t// cached box2 will have been overwritten by previous traversal\n\t\tbox2 = _box2;\n\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\tconst isC2Leaf = IS_LEAF( c2 * 2, uint16Array );\n\t\tconst c2Intersection = intersectsBoundsFunc( box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2 );\n\n\t\tlet c2StopTraversal;\n\t\tif ( c2Intersection === CONTAINED ) {\n\n\t\t\tconst offset = getLeftOffset( c2 );\n\t\t\tconst end = getRightEndOffset( c2 );\n\t\t\tconst count = end - offset;\n\n\t\t\tc2StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c2, box2 );\n\n\t\t} else {\n\n\t\t\tc2StopTraversal =\n\t\t\t\tc2Intersection &&\n\t\t\t\tshapecastTraverse(\n\t\t\t\t\tc2,\n\t\t\t\t\tgeometry,\n\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\tdepth + 1\n\t\t\t\t);\n\n\t\t}\n\n\t\tif ( c2StopTraversal ) return true;\n\n\t\treturn false;\n\n\t\t// Define these inside the function so it has access to the local variables needed\n\t\t// when converting to the buffer equivalents\n\t\tfunction getLeftOffset( nodeIndex32 ) {\n\n\t\t\tconst { uint16Array, uint32Array } = BufferStack;\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t// traverse until we find a leaf\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\tnodeIndex32 = LEFT_NODE( nodeIndex32 );\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t}\n\n\t\t\treturn OFFSET( nodeIndex32, uint32Array );\n\n\t\t}\n\n\t\tfunction getRightEndOffset( nodeIndex32 ) {\n\n\t\t\tconst { uint16Array, uint32Array } = BufferStack;\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t// traverse until we find a leaf\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\t// adjust offset to point to the right node\n\t\t\t\tnodeIndex32 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t}\n\n\t\t\t// return the end offset of the triangle range\n\t\t\treturn OFFSET( nodeIndex32, uint32Array ) + COUNT( nodeIndex16, uint16Array );\n\n\t\t}\n\n\t}\n\n}\n","import { Vector3 } from 'three';\n\nconst temp = /* @__PURE__ */ new Vector3();\nconst temp1 = /* @__PURE__ */ new Vector3();\n\nexport function closestPointToPoint(\n\tbvh,\n\tpoint,\n\ttarget = { },\n\tminThreshold = 0,\n\tmaxThreshold = Infinity,\n) {\n\n\t// early out if under minThreshold\n\t// skip checking if over maxThreshold\n\t// set minThreshold = maxThreshold to quickly check if a point is within a threshold\n\t// returns Infinity if no value found\n\tconst minThresholdSq = minThreshold * minThreshold;\n\tconst maxThresholdSq = maxThreshold * maxThreshold;\n\tlet closestDistanceSq = Infinity;\n\tlet closestDistanceTriIndex = null;\n\tbvh.shapecast(\n\n\t\t{\n\n\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\ttemp.copy( point ).clamp( box.min, box.max );\n\t\t\t\treturn temp.distanceToSquared( point );\n\n\t\t\t},\n\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\treturn score < closestDistanceSq && score < maxThresholdSq;\n\n\t\t\t},\n\n\t\t\tintersectsTriangle: ( tri, triIndex ) => {\n\n\t\t\t\ttri.closestPointToPoint( point, temp );\n\t\t\t\tconst distSq = point.distanceToSquared( temp );\n\t\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\t\ttemp1.copy( temp );\n\t\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\t\tclosestDistanceTriIndex = triIndex;\n\n\t\t\t\t}\n\n\t\t\t\tif ( distSq < minThresholdSq ) {\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t}\n\n\t);\n\n\tif ( closestDistanceSq === Infinity ) return null;\n\n\tconst closestDistance = Math.sqrt( closestDistanceSq );\n\n\tif ( ! target.point ) target.point = temp1.clone();\n\telse target.point.copy( temp1 );\n\ttarget.distance = closestDistance,\n\ttarget.faceIndex = closestDistanceTriIndex;\n\n\treturn target;\n\n}\n","import { Vector3, Vector2, Triangle, DoubleSide, BackSide, REVISION } from 'three';\n\nconst IS_GT_REVISION_169 = parseInt( REVISION ) >= 169;\n\n// Ripped and modified From THREE.js Mesh raycast\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L115\nconst _vA = /* @__PURE__ */ new Vector3();\nconst _vB = /* @__PURE__ */ new Vector3();\nconst _vC = /* @__PURE__ */ new Vector3();\n\nconst _uvA = /* @__PURE__ */ new Vector2();\nconst _uvB = /* @__PURE__ */ new Vector2();\nconst _uvC = /* @__PURE__ */ new Vector2();\n\nconst _normalA = /* @__PURE__ */ new Vector3();\nconst _normalB = /* @__PURE__ */ new Vector3();\nconst _normalC = /* @__PURE__ */ new Vector3();\n\nconst _intersectionPoint = /* @__PURE__ */ new Vector3();\nfunction checkIntersection( ray, pA, pB, pC, point, side, near, far ) {\n\n\tlet intersect;\n\tif ( side === BackSide ) {\n\n\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t} else {\n\n\t\tintersect = ray.intersectTriangle( pA, pB, pC, side !== DoubleSide, point );\n\n\t}\n\n\tif ( intersect === null ) return null;\n\n\tconst distance = ray.origin.distanceTo( point );\n\n\tif ( distance < near || distance > far ) return null;\n\n\treturn {\n\n\t\tdistance: distance,\n\t\tpoint: point.clone(),\n\n\t};\n\n}\n\nfunction checkBufferGeometryIntersection( ray, position, normal, uv, uv1, a, b, c, side, near, far ) {\n\n\t_vA.fromBufferAttribute( position, a );\n\t_vB.fromBufferAttribute( position, b );\n\t_vC.fromBufferAttribute( position, c );\n\n\tconst intersection = checkIntersection( ray, _vA, _vB, _vC, _intersectionPoint, side, near, far );\n\n\tif ( intersection ) {\n\n\t\tconst barycoord = new Vector3();\n\t\tTriangle.getBarycoord( _intersectionPoint, _vA, _vB, _vC, barycoord );\n\n\t\tif ( uv ) {\n\n\t\t\t_uvA.fromBufferAttribute( uv, a );\n\t\t\t_uvB.fromBufferAttribute( uv, b );\n\t\t\t_uvC.fromBufferAttribute( uv, c );\n\n\t\t\tintersection.uv = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );\n\n\t\t}\n\n\t\tif ( uv1 ) {\n\n\t\t\t_uvA.fromBufferAttribute( uv1, a );\n\t\t\t_uvB.fromBufferAttribute( uv1, b );\n\t\t\t_uvC.fromBufferAttribute( uv1, c );\n\n\t\t\tintersection.uv1 = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );\n\n\t\t}\n\n\t\tif ( normal ) {\n\n\t\t\t_normalA.fromBufferAttribute( normal, a );\n\t\t\t_normalB.fromBufferAttribute( normal, b );\n\t\t\t_normalC.fromBufferAttribute( normal, c );\n\n\t\t\tintersection.normal = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _normalA, _normalB, _normalC, new Vector3() );\n\t\t\tif ( intersection.normal.dot( ray.direction ) > 0 ) {\n\n\t\t\t\tintersection.normal.multiplyScalar( - 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst face = {\n\t\t\ta: a,\n\t\t\tb: b,\n\t\t\tc: c,\n\t\t\tnormal: new Vector3(),\n\t\t\tmaterialIndex: 0\n\t\t};\n\n\t\tTriangle.getNormal( _vA, _vB, _vC, face.normal );\n\n\t\tintersection.face = face;\n\t\tintersection.faceIndex = a;\n\n\t\tif ( IS_GT_REVISION_169 ) {\n\n\t\t\tintersection.barycoord = barycoord;\n\n\t\t}\n\n\t}\n\n\treturn intersection;\n\n}\n\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L258\nfunction intersectTri( geo, side, ray, tri, intersections, near, far ) {\n\n\tconst triOffset = tri * 3;\n\tlet a = triOffset + 0;\n\tlet b = triOffset + 1;\n\tlet c = triOffset + 2;\n\n\tconst index = geo.index;\n\tif ( geo.index ) {\n\n\t\ta = index.getX( a );\n\t\tb = index.getX( b );\n\t\tc = index.getX( c );\n\n\t}\n\n\tconst { position, normal, uv, uv1 } = geo.attributes;\n\tconst intersection = checkBufferGeometryIntersection( ray, position, normal, uv, uv1, a, b, c, side, near, far );\n\n\tif ( intersection ) {\n\n\t\tintersection.faceIndex = tri;\n\t\tif ( intersections ) intersections.push( intersection );\n\t\treturn intersection;\n\n\t}\n\n\treturn null;\n\n}\n\nexport { intersectTri };\n","\nimport { Vector2, Vector3, Triangle } from 'three';\n\n// sets the vertices of triangle `tri` with the 3 vertices after i\nexport function setTriangle( tri, i, index, pos ) {\n\n\tconst ta = tri.a;\n\tconst tb = tri.b;\n\tconst tc = tri.c;\n\n\tlet i0 = i;\n\tlet i1 = i + 1;\n\tlet i2 = i + 2;\n\tif ( index ) {\n\n\t\ti0 = index.getX( i0 );\n\t\ti1 = index.getX( i1 );\n\t\ti2 = index.getX( i2 );\n\n\t}\n\n\tta.x = pos.getX( i0 );\n\tta.y = pos.getY( i0 );\n\tta.z = pos.getZ( i0 );\n\n\ttb.x = pos.getX( i1 );\n\ttb.y = pos.getY( i1 );\n\ttb.z = pos.getZ( i1 );\n\n\ttc.x = pos.getX( i2 );\n\ttc.y = pos.getY( i2 );\n\ttc.z = pos.getZ( i2 );\n\n}\n\nconst tempV1 = /* @__PURE__ */ new Vector3();\nconst tempV2 = /* @__PURE__ */ new Vector3();\nconst tempV3 = /* @__PURE__ */ new Vector3();\nconst tempUV1 = /* @__PURE__ */ new Vector2();\nconst tempUV2 = /* @__PURE__ */ new Vector2();\nconst tempUV3 = /* @__PURE__ */ new Vector2();\n\nexport function getTriangleHitPointInfo( point, geometry, triangleIndex, target ) {\n\n\tconst indices = geometry.getIndex().array;\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst uvs = geometry.getAttribute( 'uv' );\n\n\tconst a = indices[ triangleIndex * 3 ];\n\tconst b = indices[ triangleIndex * 3 + 1 ];\n\tconst c = indices[ triangleIndex * 3 + 2 ];\n\n\ttempV1.fromBufferAttribute( positions, a );\n\ttempV2.fromBufferAttribute( positions, b );\n\ttempV3.fromBufferAttribute( positions, c );\n\n\t// find the associated material index\n\tlet materialIndex = 0;\n\tconst groups = geometry.groups;\n\tconst firstVertexIndex = triangleIndex * 3;\n\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\t\tconst { start, count } = group;\n\t\tif ( firstVertexIndex >= start && firstVertexIndex < start + count ) {\n\n\t\t\tmaterialIndex = group.materialIndex;\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\t// extract barycoord\n\tconst barycoord = target && target.barycoord ? target.barycoord : new Vector3();\n\tTriangle.getBarycoord( point, tempV1, tempV2, tempV3, barycoord );\n\n\t// extract uvs\n\tlet uv = null;\n\tif ( uvs ) {\n\n\t\ttempUV1.fromBufferAttribute( uvs, a );\n\t\ttempUV2.fromBufferAttribute( uvs, b );\n\t\ttempUV3.fromBufferAttribute( uvs, c );\n\n\t\tif ( target && target.uv ) uv = target.uv;\n\t\telse uv = new Vector2();\n\n\t\tTriangle.getInterpolation( point, tempV1, tempV2, tempV3, tempUV1, tempUV2, tempUV3, uv );\n\n\t}\n\n\t// adjust the provided target or create a new one\n\tif ( target ) {\n\n\t\tif ( ! target.face ) target.face = { };\n\t\ttarget.face.a = a;\n\t\ttarget.face.b = b;\n\t\ttarget.face.c = c;\n\t\ttarget.face.materialIndex = materialIndex;\n\t\tif ( ! target.face.normal ) target.face.normal = new Vector3();\n\t\tTriangle.getNormal( tempV1, tempV2, tempV3, target.face.normal );\n\n\t\tif ( uv ) target.uv = uv;\n\t\ttarget.barycoord = barycoord;\n\n\t\treturn target;\n\n\t} else {\n\n\t\treturn {\n\t\t\tface: {\n\t\t\t\ta: a,\n\t\t\t\tb: b,\n\t\t\t\tc: c,\n\t\t\t\tmaterialIndex: materialIndex,\n\t\t\t\tnormal: Triangle.getNormal( tempV1, tempV2, tempV3, new Vector3() )\n\t\t\t},\n\t\t\tuv: uv,\n\t\t\tbarycoord: barycoord,\n\t\t};\n\n\t}\n\n}\n","import { intersectTri } from '../../utils/ThreeRayIntersectUtilities.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\n\n/*************************************************************/\n/* This file is generated from \"iterationUtils.template.js\". */\n/*************************************************************/\n/* eslint-disable indent */\n\nfunction intersectTris( bvh, side, ray, offset, count, intersections, near, far ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\n\t\tintersectTri( geometry, side, ray, i, intersections, near, far );\n\n\n\t}\n\n}\n\nfunction intersectClosestTri( bvh, side, ray, offset, count, near, far ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tlet dist = Infinity;\n\tlet res = null;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tlet intersection;\n\n\t\tintersection = intersectTri( geometry, side, ray, i, null, near, far );\n\n\n\t\tif ( intersection && intersection.distance < dist ) {\n\n\t\t\tres = intersection;\n\t\t\tdist = intersection.distance;\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\nfunction iterateOverTriangles(\n\toffset,\n\tcount,\n\tbvh,\n\tintersectsTriangleFunc,\n\tcontained,\n\tdepth,\n\ttriangle\n) {\n\n\tconst { geometry } = bvh;\n\tconst { index } = geometry;\n\tconst pos = geometry.attributes.position;\n\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\tlet tri;\n\n\t\ttri = i;\n\n\t\tsetTriangle( triangle, tri * 3, index, pos );\n\t\ttriangle.needsUpdate = true;\n\n\t\tif ( intersectsTriangleFunc( triangle, tri, contained, depth ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\nexport { intersectClosestTri, intersectTris, iterateOverTriangles };\n","import { IS_LEAFNODE_FLAG } from '../Constants.js';\n\n/****************************************************/\n/* This file is generated from \"refit.template.js\". */\n/****************************************************/\n\nfunction refit( bvh, nodeIndices = null ) {\n\n\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\n\n\t\tnodeIndices = new Set( nodeIndices );\n\n\t}\n\n\tconst geometry = bvh.geometry;\n\tconst indexArr = geometry.index ? geometry.index.array : null;\n\tconst posAttr = geometry.attributes.position;\n\n\tlet buffer, uint32Array, uint16Array, float32Array;\n\tlet byteOffset = 0;\n\tconst roots = bvh._roots;\n\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\tbuffer = roots[ i ];\n\t\tuint32Array = new Uint32Array( buffer );\n\t\tuint16Array = new Uint16Array( buffer );\n\t\tfloat32Array = new Float32Array( buffer );\n\n\t\t_traverse( 0, byteOffset );\n\t\tbyteOffset += buffer.byteLength;\n\n\t}\n\n\tfunction _traverse( node32Index, byteOffset, force = false ) {\n\n\t\tconst node16Index = node32Index * 2;\n\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\n\t\t\tlet minx = Infinity;\n\t\t\tlet miny = Infinity;\n\t\t\tlet minz = Infinity;\n\t\t\tlet maxx = - Infinity;\n\t\t\tlet maxy = - Infinity;\n\t\t\tlet maxz = - Infinity;\n\n\n\t\t\tfor ( let i = 3 * offset, l = 3 * ( offset + count ); i < l; i ++ ) {\n\n\t\t\t\tlet index = indexArr[ i ];\n\t\t\t\tconst x = posAttr.getX( index );\n\t\t\t\tconst y = posAttr.getY( index );\n\t\t\t\tconst z = posAttr.getZ( index );\n\n\t\t\t\tif ( x < minx ) minx = x;\n\t\t\t\tif ( x > maxx ) maxx = x;\n\n\t\t\t\tif ( y < miny ) miny = y;\n\t\t\t\tif ( y > maxy ) maxy = y;\n\n\t\t\t\tif ( z < minz ) minz = z;\n\t\t\t\tif ( z > maxz ) maxz = z;\n\n\t\t\t}\n\n\n\t\t\tif (\n\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\n\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\n\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\n\n\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\n\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\n\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\n\t\t\t) {\n\n\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\n\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\n\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\n\n\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\n\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\n\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst left = node32Index + 8;\n\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\n\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\n\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\n\t\t\tconst offsetLeft = left + byteOffset;\n\t\t\tconst offsetRight = right + byteOffset;\n\t\t\tlet forceChildren = force;\n\t\t\tlet includesLeft = false;\n\t\t\tlet includesRight = false;\n\n\t\t\tif ( nodeIndices ) {\n\n\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\n\t\t\t\t// then we assume that all children need to be updated.\n\t\t\t\tif ( ! forceChildren ) {\n\n\t\t\t\t\tincludesLeft = nodeIndices.has( offsetLeft );\n\t\t\t\t\tincludesRight = nodeIndices.has( offsetRight );\n\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tincludesLeft = true;\n\t\t\t\tincludesRight = true;\n\n\t\t\t}\n\n\t\t\tconst traverseLeft = forceChildren || includesLeft;\n\t\t\tconst traverseRight = forceChildren || includesRight;\n\n\t\t\tlet leftChange = false;\n\t\t\tif ( traverseLeft ) {\n\n\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tlet rightChange = false;\n\t\t\tif ( traverseRight ) {\n\n\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tconst didChange = leftChange || rightChange;\n\t\t\tif ( didChange ) {\n\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tconst lefti = left + i;\n\t\t\t\t\tconst righti = right + i;\n\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\n\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\n\t\t\t\t\tconst minRightValue = float32Array[ righti ];\n\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\n\n\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn didChange;\n\n\t\t}\n\n\t}\n\n}\n\nexport { refit };\n","/**\n * This function performs intersection tests similar to Ray.intersectBox in three.js,\n * with the difference that the box values are read from an array to improve performance.\n */\nexport function intersectRay( nodeIndex32, array, ray, near, far ) {\n\n\tlet tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n\tconst invdirx = 1 / ray.direction.x,\n\t\tinvdiry = 1 / ray.direction.y,\n\t\tinvdirz = 1 / ray.direction.z;\n\n\tconst ox = ray.origin.x;\n\tconst oy = ray.origin.y;\n\tconst oz = ray.origin.z;\n\n\tlet minx = array[ nodeIndex32 ];\n\tlet maxx = array[ nodeIndex32 + 3 ];\n\n\tlet miny = array[ nodeIndex32 + 1 ];\n\tlet maxy = array[ nodeIndex32 + 3 + 1 ];\n\n\tlet minz = array[ nodeIndex32 + 2 ];\n\tlet maxz = array[ nodeIndex32 + 3 + 2 ];\n\n\tif ( invdirx >= 0 ) {\n\n\t\ttmin = ( minx - ox ) * invdirx;\n\t\ttmax = ( maxx - ox ) * invdirx;\n\n\t} else {\n\n\t\ttmin = ( maxx - ox ) * invdirx;\n\t\ttmax = ( minx - ox ) * invdirx;\n\n\t}\n\n\tif ( invdiry >= 0 ) {\n\n\t\ttymin = ( miny - oy ) * invdiry;\n\t\ttymax = ( maxy - oy ) * invdiry;\n\n\t} else {\n\n\t\ttymin = ( maxy - oy ) * invdiry;\n\t\ttymax = ( miny - oy ) * invdiry;\n\n\t}\n\n\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return false;\n\n\tif ( tymin > tmin || isNaN( tmin ) ) tmin = tymin;\n\n\tif ( tymax < tmax || isNaN( tmax ) ) tmax = tymax;\n\n\tif ( invdirz >= 0 ) {\n\n\t\ttzmin = ( minz - oz ) * invdirz;\n\t\ttzmax = ( maxz - oz ) * invdirz;\n\n\t} else {\n\n\t\ttzmin = ( maxz - oz ) * invdirz;\n\t\ttzmax = ( minz - oz ) * invdirz;\n\n\t}\n\n\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return false;\n\n\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\n\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\n\t//return point closest to the ray (positive side)\n\n\treturn tmin <= far && tmax >= near;\n\n}\n","import { intersectRay } from '../utils/intersectUtils.js';\nimport { IS_LEAF, OFFSET, COUNT, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { intersectTris } from '../utils/iterationUtils.generated.js';\nimport '../utils/iterationUtils_indirect.generated.js';\n\n/******************************************************/\n/* This file is generated from \"raycast.template.js\". */\n/******************************************************/\n\nfunction raycast( bvh, root, side, ray, intersects, near, far ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t_raycast( 0, bvh, side, ray, intersects, near, far );\n\tBufferStack.clearBuffer();\n\n}\n\nfunction _raycast( nodeIndex32, bvh, side, ray, intersects, near, far ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tconst nodeIndex16 = nodeIndex32 * 2;\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\n\t\tintersectTris( bvh, side, ray, offset, count, intersects, near, far );\n\n\n\t} else {\n\n\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\n\t\tif ( intersectRay( leftIndex, float32Array, ray, near, far ) ) {\n\n\t\t\t_raycast( leftIndex, bvh, side, ray, intersects, near, far );\n\n\t\t}\n\n\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tif ( intersectRay( rightIndex, float32Array, ray, near, far ) ) {\n\n\t\t\t_raycast( rightIndex, bvh, side, ray, intersects, near, far );\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycast };\n","import { IS_LEAF, OFFSET, COUNT, SPLIT_AXIS, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { intersectRay } from '../utils/intersectUtils.js';\nimport { intersectClosestTri } from '../utils/iterationUtils.generated.js';\nimport '../utils/iterationUtils_indirect.generated.js';\n\n/***********************************************************/\n/* This file is generated from \"raycastFirst.template.js\". */\n/***********************************************************/\n\nconst _xyzFields = [ 'x', 'y', 'z' ];\n\nfunction raycastFirst( bvh, root, side, ray, near, far ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _raycastFirst( 0, bvh, side, ray, near, far );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _raycastFirst( nodeIndex32, bvh, side, ray, near, far ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\n\t\t// eslint-disable-next-line no-unreachable\n\t\treturn intersectClosestTri( bvh, side, ray, offset, count, near, far );\n\n\n\t} else {\n\n\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\n\t\t// the ray is coming from, look for an intersection among that side of the tree first\n\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\t\tconst xyzAxis = _xyzFields[ splitAxis ];\n\t\tconst rayDir = ray.direction[ xyzAxis ];\n\t\tconst leftToRight = rayDir >= 0;\n\n\t\t// c1 is the child to check first\n\t\tlet c1, c2;\n\t\tif ( leftToRight ) {\n\n\t\t\tc1 = LEFT_NODE( nodeIndex32 );\n\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t} else {\n\n\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tc2 = LEFT_NODE( nodeIndex32 );\n\n\t\t}\n\n\t\tconst c1Intersection = intersectRay( c1, float32Array, ray, near, far );\n\t\tconst c1Result = c1Intersection ? _raycastFirst( c1, bvh, side, ray, near, far ) : null;\n\n\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\n\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\n\t\tif ( c1Result ) {\n\n\t\t\t// check if the point is within the second bounds\n\t\t\t// \"point\" is in the local frame of the bvh\n\t\t\tconst point = c1Result.point[ xyzAxis ];\n\t\t\tconst isOutside = leftToRight ?\n\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\n\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\n\n\t\t\tif ( isOutside ) {\n\n\t\t\t\treturn c1Result;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// either there was no intersection in the first node, or there could still be a closer\n\t\t// intersection in the second, so check the second node and then take the better of the two\n\t\tconst c2Intersection = intersectRay( c2, float32Array, ray, near, far );\n\t\tconst c2Result = c2Intersection ? _raycastFirst( c2, bvh, side, ray, near, far ) : null;\n\n\t\tif ( c1Result && c2Result ) {\n\n\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n\n\t\t} else {\n\n\t\t\treturn c1Result || c2Result || null;\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycastFirst };\n","import { Box3, Matrix4 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../../math/ExtendedTriangle.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { IS_LEAF, OFFSET, COUNT, BOUNDING_DATA_INDEX } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\n\n/*****************************************************************/\n/* This file is generated from \"intersectsGeometry.template.js\". */\n/*****************************************************************/\n/* eslint-disable indent */\n\nconst boundingBox = /* @__PURE__ */ new Box3();\nconst triangle = /* @__PURE__ */ new ExtendedTriangle();\nconst triangle2 = /* @__PURE__ */ new ExtendedTriangle();\nconst invertedMat = /* @__PURE__ */ new Matrix4();\n\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\n\nfunction intersectsGeometry( bvh, root, otherGeometry, geometryToBvh ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _intersectsGeometry( 0, bvh, otherGeometry, geometryToBvh );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _intersectsGeometry( nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tif ( cachedObb === null ) {\n\n\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\totherGeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\tcachedObb = obb;\n\n\t}\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst thisGeometry = bvh.geometry;\n\t\tconst thisIndex = thisGeometry.index;\n\t\tconst thisPos = thisGeometry.attributes.position;\n\n\t\tconst index = otherGeometry.index;\n\t\tconst pos = otherGeometry.attributes.position;\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\n\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\n\t\t// here.\n\t\tinvertedMat.copy( geometryToBvh ).invert();\n\n\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t// if there's a bounds tree\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2 );\n\t\t\tobb2.matrix.copy( invertedMat );\n\t\t\tobb2.needsUpdate = true;\n\n\t\t\t// TODO: use a triangle iteration function here\n\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\n\n\t\t\t\tintersectsBounds: box => obb2.intersectsBox( box ),\n\n\t\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.needsUpdate = true;\n\n\n\t\t\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\t\tsetTriangle( triangle2, i, thisIndex, thisPos );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn res;\n\n\t\t} else {\n\n\t\t\t// if we're just dealing with raw geometry\n\n\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\tsetTriangle( triangle, i, thisIndex, thisPos );\n\n\n\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\tsetTriangle( triangle2, i2, index, pos );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t}\n\n\n\t\t}\n\n\t} else {\n\n\t\tconst left = nodeIndex32 + 8;\n\t\tconst right = uint32Array[ nodeIndex32 + 6 ];\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox );\n\t\tconst leftIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( left, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( leftIntersection ) return true;\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox );\n\t\tconst rightIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( right, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( rightIntersection ) return true;\n\n\t\treturn false;\n\n\t}\n\n}\n\nexport { intersectsGeometry };\n","import { Matrix4, Vector3 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { getTriCount } from '../build/geometryUtils.js';\nimport { ExtendedTrianglePool } from '../../utils/ExtendedTrianglePool.js';\n\n/*********************************************************************/\n/* This file is generated from \"closestPointToGeometry.template.js\". */\n/*********************************************************************/\n\nconst tempMatrix = /* @__PURE__ */ new Matrix4();\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\nconst temp1 = /* @__PURE__ */ new Vector3();\nconst temp2 = /* @__PURE__ */ new Vector3();\nconst temp3 = /* @__PURE__ */ new Vector3();\nconst temp4 = /* @__PURE__ */ new Vector3();\n\nfunction closestPointToGeometry(\n\tbvh,\n\totherGeometry,\n\tgeometryToBvh,\n\ttarget1 = { },\n\ttarget2 = { },\n\tminThreshold = 0,\n\tmaxThreshold = Infinity,\n) {\n\n\tif ( ! otherGeometry.boundingBox ) {\n\n\t\totherGeometry.computeBoundingBox();\n\n\t}\n\n\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\tobb.needsUpdate = true;\n\n\tconst geometry = bvh.geometry;\n\tconst pos = geometry.attributes.position;\n\tconst index = geometry.index;\n\tconst otherPos = otherGeometry.attributes.position;\n\tconst otherIndex = otherGeometry.index;\n\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\n\tlet tempTarget1 = temp1;\n\tlet tempTargetDest1 = temp2;\n\tlet tempTarget2 = null;\n\tlet tempTargetDest2 = null;\n\n\tif ( target2 ) {\n\n\t\ttempTarget2 = temp3;\n\t\ttempTargetDest2 = temp4;\n\n\t}\n\n\tlet closestDistance = Infinity;\n\tlet closestDistanceTriIndex = null;\n\tlet closestDistanceOtherTriIndex = null;\n\ttempMatrix.copy( geometryToBvh ).invert();\n\tobb2.matrix.copy( tempMatrix );\n\tbvh.shapecast(\n\t\t{\n\n\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\treturn obb.distanceToBox( box );\n\n\t\t\t},\n\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\n\n\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\n\t\t\t\t\t// save the bounds to use during triangle checks.\n\t\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t\tobb2.min.copy( box.min );\n\t\t\t\t\t\tobb2.max.copy( box.max );\n\t\t\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t},\n\n\t\t\tintersectsRange: ( offset, count ) => {\n\n\t\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n\t\t\t\t\t// the closest bounds in the other geometry to check.\n\t\t\t\t\tconst otherBvh = otherGeometry.boundsTree;\n\t\t\t\t\treturn otherBvh.shapecast( {\n\t\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\n\n\t\t\t\t\t\t\tfor ( let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2 ++ ) {\n\n\n\t\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\n\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle, 3 * i, index, pos );\n\n\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t},\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\n\t\t\t\t\tconst triCount = getTriCount( otherGeometry );\n\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\n\t\t\t\t\t\t\tsetTriangle( triangle, 3 * i, index, pos );\n\n\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t}\n\n\t);\n\n\tExtendedTrianglePool.releasePrimitive( triangle );\n\tExtendedTrianglePool.releasePrimitive( triangle2 );\n\n\tif ( closestDistance === Infinity ) {\n\n\t\treturn null;\n\n\t}\n\n\tif ( ! target1.point ) {\n\n\t\ttarget1.point = tempTargetDest1.clone();\n\n\t} else {\n\n\t\ttarget1.point.copy( tempTargetDest1 );\n\n\t}\n\n\ttarget1.distance = closestDistance,\n\ttarget1.faceIndex = closestDistanceTriIndex;\n\n\tif ( target2 ) {\n\n\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\n\t\telse target2.point.copy( tempTargetDest2 );\n\t\ttarget2.point.applyMatrix4( tempMatrix );\n\t\ttempTargetDest1.applyMatrix4( tempMatrix );\n\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\n\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\n\n\t}\n\n\treturn target1;\n\n}\n\nexport { closestPointToGeometry };\n","import { intersectTri } from '../../utils/ThreeRayIntersectUtilities.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\n\n/*************************************************************/\n/* This file is generated from \"iterationUtils.template.js\". */\n/*************************************************************/\n/* eslint-disable indent */\n\nfunction intersectTris_indirect( bvh, side, ray, offset, count, intersections, near, far ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tlet vi = _indirectBuffer ? _indirectBuffer[ i ] : i;\n\t\tintersectTri( geometry, side, ray, vi, intersections, near, far );\n\n\n\t}\n\n}\n\nfunction intersectClosestTri_indirect( bvh, side, ray, offset, count, near, far ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tlet dist = Infinity;\n\tlet res = null;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tlet intersection;\n\t\tintersection = intersectTri( geometry, side, ray, _indirectBuffer ? _indirectBuffer[ i ] : i, null, near, far );\n\n\n\t\tif ( intersection && intersection.distance < dist ) {\n\n\t\t\tres = intersection;\n\t\t\tdist = intersection.distance;\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\nfunction iterateOverTriangles_indirect(\n\toffset,\n\tcount,\n\tbvh,\n\tintersectsTriangleFunc,\n\tcontained,\n\tdepth,\n\ttriangle\n) {\n\n\tconst { geometry } = bvh;\n\tconst { index } = geometry;\n\tconst pos = geometry.attributes.position;\n\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\tlet tri;\n\t\ttri = bvh.resolveTriangleIndex( i );\n\n\t\tsetTriangle( triangle, tri * 3, index, pos );\n\t\ttriangle.needsUpdate = true;\n\n\t\tif ( intersectsTriangleFunc( triangle, tri, contained, depth ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\nexport { intersectClosestTri_indirect, intersectTris_indirect, iterateOverTriangles_indirect };\n","import { IS_LEAFNODE_FLAG } from '../Constants.js';\n\n/****************************************************/\n/* This file is generated from \"refit.template.js\". */\n/****************************************************/\n\nfunction refit_indirect( bvh, nodeIndices = null ) {\n\n\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\n\n\t\tnodeIndices = new Set( nodeIndices );\n\n\t}\n\n\tconst geometry = bvh.geometry;\n\tconst indexArr = geometry.index ? geometry.index.array : null;\n\tconst posAttr = geometry.attributes.position;\n\n\tlet buffer, uint32Array, uint16Array, float32Array;\n\tlet byteOffset = 0;\n\tconst roots = bvh._roots;\n\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\tbuffer = roots[ i ];\n\t\tuint32Array = new Uint32Array( buffer );\n\t\tuint16Array = new Uint16Array( buffer );\n\t\tfloat32Array = new Float32Array( buffer );\n\n\t\t_traverse( 0, byteOffset );\n\t\tbyteOffset += buffer.byteLength;\n\n\t}\n\n\tfunction _traverse( node32Index, byteOffset, force = false ) {\n\n\t\tconst node16Index = node32Index * 2;\n\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\n\t\t\tlet minx = Infinity;\n\t\t\tlet miny = Infinity;\n\t\t\tlet minz = Infinity;\n\t\t\tlet maxx = - Infinity;\n\t\t\tlet maxy = - Infinity;\n\t\t\tlet maxz = - Infinity;\n\n\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\tconst t = 3 * bvh.resolveTriangleIndex( i );\n\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\tlet index = t + j;\n\t\t\t\t\tindex = indexArr ? indexArr[ index ] : index;\n\n\t\t\t\t\tconst x = posAttr.getX( index );\n\t\t\t\t\tconst y = posAttr.getY( index );\n\t\t\t\t\tconst z = posAttr.getZ( index );\n\n\t\t\t\t\tif ( x < minx ) minx = x;\n\t\t\t\t\tif ( x > maxx ) maxx = x;\n\n\t\t\t\t\tif ( y < miny ) miny = y;\n\t\t\t\t\tif ( y > maxy ) maxy = y;\n\n\t\t\t\t\tif ( z < minz ) minz = z;\n\t\t\t\t\tif ( z > maxz ) maxz = z;\n\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tif (\n\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\n\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\n\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\n\n\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\n\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\n\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\n\t\t\t) {\n\n\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\n\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\n\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\n\n\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\n\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\n\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst left = node32Index + 8;\n\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\n\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\n\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\n\t\t\tconst offsetLeft = left + byteOffset;\n\t\t\tconst offsetRight = right + byteOffset;\n\t\t\tlet forceChildren = force;\n\t\t\tlet includesLeft = false;\n\t\t\tlet includesRight = false;\n\n\t\t\tif ( nodeIndices ) {\n\n\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\n\t\t\t\t// then we assume that all children need to be updated.\n\t\t\t\tif ( ! forceChildren ) {\n\n\t\t\t\t\tincludesLeft = nodeIndices.has( offsetLeft );\n\t\t\t\t\tincludesRight = nodeIndices.has( offsetRight );\n\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tincludesLeft = true;\n\t\t\t\tincludesRight = true;\n\n\t\t\t}\n\n\t\t\tconst traverseLeft = forceChildren || includesLeft;\n\t\t\tconst traverseRight = forceChildren || includesRight;\n\n\t\t\tlet leftChange = false;\n\t\t\tif ( traverseLeft ) {\n\n\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tlet rightChange = false;\n\t\t\tif ( traverseRight ) {\n\n\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tconst didChange = leftChange || rightChange;\n\t\t\tif ( didChange ) {\n\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tconst lefti = left + i;\n\t\t\t\t\tconst righti = right + i;\n\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\n\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\n\t\t\t\t\tconst minRightValue = float32Array[ righti ];\n\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\n\n\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn didChange;\n\n\t\t}\n\n\t}\n\n}\n\nexport { refit_indirect };\n","import { intersectRay } from '../utils/intersectUtils.js';\nimport { IS_LEAF, OFFSET, COUNT, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport '../utils/iterationUtils.generated.js';\nimport { intersectTris_indirect } from '../utils/iterationUtils_indirect.generated.js';\n\n/******************************************************/\n/* This file is generated from \"raycast.template.js\". */\n/******************************************************/\n\nfunction raycast_indirect( bvh, root, side, ray, intersects, near, far ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t_raycast( 0, bvh, side, ray, intersects, near, far );\n\tBufferStack.clearBuffer();\n\n}\n\nfunction _raycast( nodeIndex32, bvh, side, ray, intersects, near, far ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tconst nodeIndex16 = nodeIndex32 * 2;\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\tintersectTris_indirect( bvh, side, ray, offset, count, intersects, near, far );\n\n\n\t} else {\n\n\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\n\t\tif ( intersectRay( leftIndex, float32Array, ray, near, far ) ) {\n\n\t\t\t_raycast( leftIndex, bvh, side, ray, intersects, near, far );\n\n\t\t}\n\n\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tif ( intersectRay( rightIndex, float32Array, ray, near, far ) ) {\n\n\t\t\t_raycast( rightIndex, bvh, side, ray, intersects, near, far );\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycast_indirect };\n","import { IS_LEAF, OFFSET, COUNT, SPLIT_AXIS, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { intersectRay } from '../utils/intersectUtils.js';\nimport '../utils/iterationUtils.generated.js';\nimport { intersectClosestTri_indirect } from '../utils/iterationUtils_indirect.generated.js';\n\n/***********************************************************/\n/* This file is generated from \"raycastFirst.template.js\". */\n/***********************************************************/\n\nconst _xyzFields = [ 'x', 'y', 'z' ];\n\nfunction raycastFirst_indirect( bvh, root, side, ray, near, far ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _raycastFirst( 0, bvh, side, ray, near, far );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _raycastFirst( nodeIndex32, bvh, side, ray, near, far ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\treturn intersectClosestTri_indirect( bvh, side, ray, offset, count, near, far );\n\n\n\t} else {\n\n\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\n\t\t// the ray is coming from, look for an intersection among that side of the tree first\n\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\t\tconst xyzAxis = _xyzFields[ splitAxis ];\n\t\tconst rayDir = ray.direction[ xyzAxis ];\n\t\tconst leftToRight = rayDir >= 0;\n\n\t\t// c1 is the child to check first\n\t\tlet c1, c2;\n\t\tif ( leftToRight ) {\n\n\t\t\tc1 = LEFT_NODE( nodeIndex32 );\n\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t} else {\n\n\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tc2 = LEFT_NODE( nodeIndex32 );\n\n\t\t}\n\n\t\tconst c1Intersection = intersectRay( c1, float32Array, ray, near, far );\n\t\tconst c1Result = c1Intersection ? _raycastFirst( c1, bvh, side, ray, near, far ) : null;\n\n\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\n\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\n\t\tif ( c1Result ) {\n\n\t\t\t// check if the point is within the second bounds\n\t\t\t// \"point\" is in the local frame of the bvh\n\t\t\tconst point = c1Result.point[ xyzAxis ];\n\t\t\tconst isOutside = leftToRight ?\n\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\n\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\n\n\t\t\tif ( isOutside ) {\n\n\t\t\t\treturn c1Result;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// either there was no intersection in the first node, or there could still be a closer\n\t\t// intersection in the second, so check the second node and then take the better of the two\n\t\tconst c2Intersection = intersectRay( c2, float32Array, ray, near, far );\n\t\tconst c2Result = c2Intersection ? _raycastFirst( c2, bvh, side, ray, near, far ) : null;\n\n\t\tif ( c1Result && c2Result ) {\n\n\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n\n\t\t} else {\n\n\t\t\treturn c1Result || c2Result || null;\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycastFirst_indirect };\n","import { Box3, Matrix4 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../../math/ExtendedTriangle.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { IS_LEAF, OFFSET, COUNT, BOUNDING_DATA_INDEX } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\n\n/*****************************************************************/\n/* This file is generated from \"intersectsGeometry.template.js\". */\n/*****************************************************************/\n/* eslint-disable indent */\n\nconst boundingBox = /* @__PURE__ */ new Box3();\nconst triangle = /* @__PURE__ */ new ExtendedTriangle();\nconst triangle2 = /* @__PURE__ */ new ExtendedTriangle();\nconst invertedMat = /* @__PURE__ */ new Matrix4();\n\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\n\nfunction intersectsGeometry_indirect( bvh, root, otherGeometry, geometryToBvh ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _intersectsGeometry( 0, bvh, otherGeometry, geometryToBvh );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _intersectsGeometry( nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tif ( cachedObb === null ) {\n\n\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\totherGeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\tcachedObb = obb;\n\n\t}\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst thisGeometry = bvh.geometry;\n\t\tconst thisIndex = thisGeometry.index;\n\t\tconst thisPos = thisGeometry.attributes.position;\n\n\t\tconst index = otherGeometry.index;\n\t\tconst pos = otherGeometry.attributes.position;\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\n\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\n\t\t// here.\n\t\tinvertedMat.copy( geometryToBvh ).invert();\n\n\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t// if there's a bounds tree\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2 );\n\t\t\tobb2.matrix.copy( invertedMat );\n\t\t\tobb2.needsUpdate = true;\n\n\t\t\t// TODO: use a triangle iteration function here\n\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\n\n\t\t\t\tintersectsBounds: box => obb2.intersectsBox( box ),\n\n\t\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * bvh.resolveTriangleIndex( i ), thisIndex, thisPos );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn res;\n\n\t\t} else {\n\n\t\t\t// if we're just dealing with raw geometry\n\t\t\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\tsetTriangle( triangle, 3 * ti, thisIndex, thisPos );\n\n\n\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\tsetTriangle( triangle2, i2, index, pos );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t}\n\n\t} else {\n\n\t\tconst left = nodeIndex32 + 8;\n\t\tconst right = uint32Array[ nodeIndex32 + 6 ];\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox );\n\t\tconst leftIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( left, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( leftIntersection ) return true;\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox );\n\t\tconst rightIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( right, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( rightIntersection ) return true;\n\n\t\treturn false;\n\n\t}\n\n}\n\nexport { intersectsGeometry_indirect };\n","import { Matrix4, Vector3 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { getTriCount } from '../build/geometryUtils.js';\nimport { ExtendedTrianglePool } from '../../utils/ExtendedTrianglePool.js';\n\n/*********************************************************************/\n/* This file is generated from \"closestPointToGeometry.template.js\". */\n/*********************************************************************/\n\nconst tempMatrix = /* @__PURE__ */ new Matrix4();\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\nconst temp1 = /* @__PURE__ */ new Vector3();\nconst temp2 = /* @__PURE__ */ new Vector3();\nconst temp3 = /* @__PURE__ */ new Vector3();\nconst temp4 = /* @__PURE__ */ new Vector3();\n\nfunction closestPointToGeometry_indirect(\n\tbvh,\n\totherGeometry,\n\tgeometryToBvh,\n\ttarget1 = { },\n\ttarget2 = { },\n\tminThreshold = 0,\n\tmaxThreshold = Infinity,\n) {\n\n\tif ( ! otherGeometry.boundingBox ) {\n\n\t\totherGeometry.computeBoundingBox();\n\n\t}\n\n\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\tobb.needsUpdate = true;\n\n\tconst geometry = bvh.geometry;\n\tconst pos = geometry.attributes.position;\n\tconst index = geometry.index;\n\tconst otherPos = otherGeometry.attributes.position;\n\tconst otherIndex = otherGeometry.index;\n\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\n\tlet tempTarget1 = temp1;\n\tlet tempTargetDest1 = temp2;\n\tlet tempTarget2 = null;\n\tlet tempTargetDest2 = null;\n\n\tif ( target2 ) {\n\n\t\ttempTarget2 = temp3;\n\t\ttempTargetDest2 = temp4;\n\n\t}\n\n\tlet closestDistance = Infinity;\n\tlet closestDistanceTriIndex = null;\n\tlet closestDistanceOtherTriIndex = null;\n\ttempMatrix.copy( geometryToBvh ).invert();\n\tobb2.matrix.copy( tempMatrix );\n\tbvh.shapecast(\n\t\t{\n\n\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\treturn obb.distanceToBox( box );\n\n\t\t\t},\n\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\n\n\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\n\t\t\t\t\t// save the bounds to use during triangle checks.\n\t\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t\tobb2.min.copy( box.min );\n\t\t\t\t\t\tobb2.max.copy( box.max );\n\t\t\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t},\n\n\t\t\tintersectsRange: ( offset, count ) => {\n\n\t\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n\t\t\t\t\t// the closest bounds in the other geometry to check.\n\t\t\t\t\tconst otherBvh = otherGeometry.boundsTree;\n\t\t\t\t\treturn otherBvh.shapecast( {\n\t\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\n\n\t\t\t\t\t\t\tfor ( let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\t\t\tconst ti2 = otherBvh.resolveTriangleIndex( i2 );\n\t\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * ti2, otherIndex, otherPos );\n\n\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle, 3 * ti, index, pos );\n\n\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t},\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\n\t\t\t\t\tconst triCount = getTriCount( otherGeometry );\n\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\t\t\t\tsetTriangle( triangle, 3 * ti, index, pos );\n\n\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t}\n\n\t);\n\n\tExtendedTrianglePool.releasePrimitive( triangle );\n\tExtendedTrianglePool.releasePrimitive( triangle2 );\n\n\tif ( closestDistance === Infinity ) {\n\n\t\treturn null;\n\n\t}\n\n\tif ( ! target1.point ) {\n\n\t\ttarget1.point = tempTargetDest1.clone();\n\n\t} else {\n\n\t\ttarget1.point.copy( tempTargetDest1 );\n\n\t}\n\n\ttarget1.distance = closestDistance,\n\ttarget1.faceIndex = closestDistanceTriIndex;\n\n\tif ( target2 ) {\n\n\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\n\t\telse target2.point.copy( tempTargetDest2 );\n\t\ttarget2.point.applyMatrix4( tempMatrix );\n\t\ttempTargetDest1.applyMatrix4( tempMatrix );\n\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\n\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\n\n\t}\n\n\treturn target1;\n\n}\n\nexport { closestPointToGeometry_indirect };\n","export function isSharedArrayBufferSupported() {\n\n\treturn typeof SharedArrayBuffer !== 'undefined';\n\n}\n\nexport function convertToBufferType( array, BufferConstructor ) {\n\n\tif ( array === null ) {\n\n\t\treturn array;\n\n\t} else if ( array.buffer ) {\n\n\t\tconst buffer = array.buffer;\n\t\tif ( buffer.constructor === BufferConstructor ) {\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tconst ArrayConstructor = array.constructor;\n\t\tconst result = new ArrayConstructor( new BufferConstructor( buffer.byteLength ) );\n\t\tresult.set( array );\n\t\treturn result;\n\n\t} else {\n\n\t\tif ( array.constructor === BufferConstructor ) {\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tconst result = new BufferConstructor( array.byteLength );\n\t\tnew Uint8Array( result ).set( new Uint8Array( array ) );\n\t\treturn result;\n\n\t}\n\n}\n","import { Box3, Matrix4 } from 'three';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { BOUNDING_DATA_INDEX, COUNT, IS_LEAF, LEFT_NODE, OFFSET, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { PrimitivePool } from '../../utils/PrimitivePool.js';\n\nconst _bufferStack1 = new BufferStack.constructor();\nconst _bufferStack2 = new BufferStack.constructor();\nconst _boxPool = new PrimitivePool( () => new Box3() );\nconst _leftBox1 = new Box3();\nconst _rightBox1 = new Box3();\n\nconst _leftBox2 = new Box3();\nconst _rightBox2 = new Box3();\n\nlet _active = false;\n\nexport function bvhcast( bvh, otherBvh, matrixToLocal, intersectsRanges ) {\n\n\tif ( _active ) {\n\n\t\tthrow new Error( 'MeshBVH: Recursive calls to bvhcast not supported.' );\n\n\t}\n\n\t_active = true;\n\n\tconst roots = bvh._roots;\n\tconst otherRoots = otherBvh._roots;\n\tlet result;\n\tlet offset1 = 0;\n\tlet offset2 = 0;\n\tconst invMat = new Matrix4().copy( matrixToLocal ).invert();\n\n\t// iterate over the first set of roots\n\tfor ( let i = 0, il = roots.length; i < il; i ++ ) {\n\n\t\t_bufferStack1.setBuffer( roots[ i ] );\n\t\toffset2 = 0;\n\n\t\t// prep the initial root box\n\t\tconst localBox = _boxPool.getPrimitive();\n\t\tarrayToBox( BOUNDING_DATA_INDEX( 0 ), _bufferStack1.float32Array, localBox );\n\t\tlocalBox.applyMatrix4( invMat );\n\n\t\t// iterate over the second set of roots\n\t\tfor ( let j = 0, jl = otherRoots.length; j < jl; j ++ ) {\n\n\t\t\t_bufferStack2.setBuffer( otherRoots[ j ] );\n\n\t\t\tresult = _traverse(\n\t\t\t\t0, 0, matrixToLocal, invMat, intersectsRanges,\n\t\t\t\toffset1, offset2, 0, 0,\n\t\t\t\tlocalBox,\n\t\t\t);\n\n\t\t\t_bufferStack2.clearBuffer();\n\t\t\toffset2 += otherRoots[ j ].length;\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// release stack info\n\t\t_boxPool.releasePrimitive( localBox );\n\t\t_bufferStack1.clearBuffer();\n\t\toffset1 += roots[ i ].length;\n\n\t\tif ( result ) {\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\t_active = false;\n\treturn result;\n\n}\n\nfunction _traverse(\n\tnode1Index32,\n\tnode2Index32,\n\tmatrix2to1,\n\tmatrix1to2,\n\tintersectsRangesFunc,\n\n\t// offsets for ids\n\tnode1IndexByteOffset = 0,\n\tnode2IndexByteOffset = 0,\n\n\t// tree depth\n\tdepth1 = 0,\n\tdepth2 = 0,\n\n\tcurrBox = null,\n\treversed = false,\n\n) {\n\n\t// get the buffer stacks associated with the current indices\n\tlet bufferStack1, bufferStack2;\n\tif ( reversed ) {\n\n\t\tbufferStack1 = _bufferStack2;\n\t\tbufferStack2 = _bufferStack1;\n\n\t} else {\n\n\t\tbufferStack1 = _bufferStack1;\n\t\tbufferStack2 = _bufferStack2;\n\n\t}\n\n\t// get the local instances of the typed buffers\n\tconst\n\t\tfloat32Array1 = bufferStack1.float32Array,\n\t\tuint32Array1 = bufferStack1.uint32Array,\n\t\tuint16Array1 = bufferStack1.uint16Array,\n\t\tfloat32Array2 = bufferStack2.float32Array,\n\t\tuint32Array2 = bufferStack2.uint32Array,\n\t\tuint16Array2 = bufferStack2.uint16Array;\n\n\tconst node1Index16 = node1Index32 * 2;\n\tconst node2Index16 = node2Index32 * 2;\n\tconst isLeaf1 = IS_LEAF( node1Index16, uint16Array1 );\n\tconst isLeaf2 = IS_LEAF( node2Index16, uint16Array2 );\n\tlet result = false;\n\tif ( isLeaf2 && isLeaf1 ) {\n\n\t\t// if both bounds are leaf nodes then fire the callback if the boxes intersect\n\t\tif ( reversed ) {\n\n\t\t\tresult = intersectsRangesFunc(\n\t\t\t\tOFFSET( node2Index32, uint32Array2 ), COUNT( node2Index32 * 2, uint16Array2 ),\n\t\t\t\tOFFSET( node1Index32, uint32Array1 ), COUNT( node1Index32 * 2, uint16Array1 ),\n\t\t\t\tdepth2, node2IndexByteOffset + node2Index32,\n\t\t\t\tdepth1, node1IndexByteOffset + node1Index32,\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tresult = intersectsRangesFunc(\n\t\t\t\tOFFSET( node1Index32, uint32Array1 ), COUNT( node1Index32 * 2, uint16Array1 ),\n\t\t\t\tOFFSET( node2Index32, uint32Array2 ), COUNT( node2Index32 * 2, uint16Array2 ),\n\t\t\t\tdepth1, node1IndexByteOffset + node1Index32,\n\t\t\t\tdepth2, node2IndexByteOffset + node2Index32,\n\t\t\t);\n\n\t\t}\n\n\t} else if ( isLeaf2 ) {\n\n\t\t// SWAP\n\t\t// If we've traversed to the leaf node on the other bvh then we need to swap over\n\t\t// to traverse down the first one\n\n\t\t// get the new box to use\n\t\tconst newBox = _boxPool.getPrimitive();\n\t\tarrayToBox( BOUNDING_DATA_INDEX( node2Index32 ), float32Array2, newBox );\n\t\tnewBox.applyMatrix4( matrix2to1 );\n\n\t\t// get the child bounds to check before traversal\n\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\tresult = (\n\t\t\tintersectCl1 && _traverse(\n\t\t\t\tnode2Index32, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\tnewBox, ! reversed,\n\t\t\t)\n\t\t) || (\n\t\t\tintersectCr1 && _traverse(\n\t\t\t\tnode2Index32, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\tnewBox, ! reversed,\n\t\t\t)\n\t\t);\n\n\t\t_boxPool.releasePrimitive( newBox );\n\n\t} else {\n\n\t\t// if neither are leaves then we should swap if one of the children does not\n\t\t// intersect with the current bounds\n\n\t\t// get the child bounds to check\n\t\tconst cl2 = LEFT_NODE( node2Index32 );\n\t\tconst cr2 = RIGHT_NODE( node2Index32, uint32Array2 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cl2 ), float32Array2, _leftBox2 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cr2 ), float32Array2, _rightBox2 );\n\n\t\tconst leftIntersects = currBox.intersectsBox( _leftBox2 );\n\t\tconst rightIntersects = currBox.intersectsBox( _rightBox2 );\n\t\tif ( leftIntersects && rightIntersects ) {\n\n\t\t\t// continue to traverse both children if they both intersect\n\t\t\tresult = _traverse(\n\t\t\t\tnode1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\tcurrBox, reversed,\n\t\t\t) || _traverse(\n\t\t\t\tnode1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\tcurrBox, reversed,\n\t\t\t);\n\n\t\t} else if ( leftIntersects ) {\n\n\t\t\tif ( isLeaf1 ) {\n\n\t\t\t\t// if the current box is a leaf then just continue\n\t\t\t\tresult = _traverse(\n\t\t\t\t\tnode1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\t\tcurrBox, reversed,\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\t// SWAP\n\t\t\t\t// if only one box intersects then we have to swap to the other bvh to continue\n\t\t\t\tconst newBox = _boxPool.getPrimitive();\n\t\t\t\tnewBox.copy( _leftBox2 ).applyMatrix4( matrix2to1 );\n\n\t\t\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\t\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\t\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\t\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\t\t\tresult = (\n\t\t\t\t\tintersectCl1 && _traverse(\n\t\t\t\t\t\tcl2, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t) || (\n\t\t\t\t\tintersectCr1 && _traverse(\n\t\t\t\t\t\tcl2, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t\t_boxPool.releasePrimitive( newBox );\n\n\t\t\t}\n\n\t\t} else if ( rightIntersects ) {\n\n\t\t\tif ( isLeaf1 ) {\n\n\t\t\t\t// if the current box is a leaf then just continue\n\t\t\t\tresult = _traverse(\n\t\t\t\t\tnode1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\t\tcurrBox, reversed,\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\t// SWAP\n\t\t\t\t// if only one box intersects then we have to swap to the other bvh to continue\n\t\t\t\tconst newBox = _boxPool.getPrimitive();\n\t\t\t\tnewBox.copy( _rightBox2 ).applyMatrix4( matrix2to1 );\n\n\t\t\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\t\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\t\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\t\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\t\t\tresult = (\n\t\t\t\t\tintersectCl1 && _traverse(\n\t\t\t\t\t\tcr2, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t) || (\n\t\t\t\t\tintersectCr1 && _traverse(\n\t\t\t\t\t\tcr2, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t\t_boxPool.releasePrimitive( newBox );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn result;\n\n}\n\n","import { BufferAttribute, Box3, FrontSide } from 'three';\nimport { CENTER, BYTES_PER_NODE, IS_LEAFNODE_FLAG, SKIP_GENERATION } from './Constants.js';\nimport { buildPackedTree } from './build/buildTree.js';\nimport { OrientedBox } from '../math/OrientedBox.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { ExtendedTrianglePool } from '../utils/ExtendedTrianglePool.js';\nimport { shapecast } from './cast/shapecast.js';\nimport { closestPointToPoint } from './cast/closestPointToPoint.js';\n\nimport { iterateOverTriangles } from './utils/iterationUtils.generated.js';\nimport { refit } from './cast/refit.generated.js';\nimport { raycast } from './cast/raycast.generated.js';\nimport { raycastFirst } from './cast/raycastFirst.generated.js';\nimport { intersectsGeometry } from './cast/intersectsGeometry.generated.js';\nimport { closestPointToGeometry } from './cast/closestPointToGeometry.generated.js';\n\nimport { iterateOverTriangles_indirect } from './utils/iterationUtils_indirect.generated.js';\nimport { refit_indirect } from './cast/refit_indirect.generated.js';\nimport { raycast_indirect } from './cast/raycast_indirect.generated.js';\nimport { raycastFirst_indirect } from './cast/raycastFirst_indirect.generated.js';\nimport { intersectsGeometry_indirect } from './cast/intersectsGeometry_indirect.generated.js';\nimport { closestPointToGeometry_indirect } from './cast/closestPointToGeometry_indirect.generated.js';\nimport { isSharedArrayBufferSupported } from '../utils/BufferUtils.js';\nimport { setTriangle } from '../utils/TriangleUtilities.js';\nimport { bvhcast } from './cast/bvhcast.js';\n\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst tempBox = /* @__PURE__ */ new Box3();\nexport const DEFAULT_OPTIONS = {\n\tstrategy: CENTER,\n\tmaxDepth: 40,\n\tmaxLeafTris: 10,\n\tuseSharedArrayBuffer: false,\n\tsetBoundingBox: true,\n\tonProgress: null,\n\tindirect: false,\n\tverbose: true,\n\trange: null\n};\n\nexport class MeshBVH {\n\n\tstatic serialize( bvh, options = {} ) {\n\n\t\toptions = {\n\t\t\tcloneBuffers: true,\n\t\t\t...options,\n\t\t};\n\n\t\tconst geometry = bvh.geometry;\n\t\tconst rootData = bvh._roots;\n\t\tconst indirectBuffer = bvh._indirectBuffer;\n\t\tconst indexAttribute = geometry.getIndex();\n\t\tlet result;\n\t\tif ( options.cloneBuffers ) {\n\n\t\t\tresult = {\n\t\t\t\troots: rootData.map( root => root.slice() ),\n\t\t\t\tindex: indexAttribute ? indexAttribute.array.slice() : null,\n\t\t\t\tindirectBuffer: indirectBuffer ? indirectBuffer.slice() : null,\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tresult = {\n\t\t\t\troots: rootData,\n\t\t\t\tindex: indexAttribute ? indexAttribute.array : null,\n\t\t\t\tindirectBuffer: indirectBuffer,\n\t\t\t};\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tstatic deserialize( data, geometry, options = {} ) {\n\n\t\toptions = {\n\t\t\tsetIndex: true,\n\t\t\tindirect: Boolean( data.indirectBuffer ),\n\t\t\t...options,\n\t\t};\n\n\t\tconst { index, roots, indirectBuffer } = data;\n\t\tconst bvh = new MeshBVH( geometry, { ...options, [ SKIP_GENERATION ]: true } );\n\t\tbvh._roots = roots;\n\t\tbvh._indirectBuffer = indirectBuffer || null;\n\n\t\tif ( options.setIndex ) {\n\n\t\t\tconst indexAttribute = geometry.getIndex();\n\t\t\tif ( indexAttribute === null ) {\n\n\t\t\t\tconst newIndex = new BufferAttribute( data.index, 1, false );\n\t\t\t\tgeometry.setIndex( newIndex );\n\n\t\t\t} else if ( indexAttribute.array !== index ) {\n\n\t\t\t\tindexAttribute.array.set( index );\n\t\t\t\tindexAttribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bvh;\n\n\t}\n\n\tget indirect() {\n\n\t\treturn ! ! this._indirectBuffer;\n\n\t}\n\n\tconstructor( geometry, options = {} ) {\n\n\t\tif ( ! geometry.isBufferGeometry ) {\n\n\t\t\tthrow new Error( 'MeshBVH: Only BufferGeometries are supported.' );\n\n\t\t} else if ( geometry.index && geometry.index.isInterleavedBufferAttribute ) {\n\n\t\t\tthrow new Error( 'MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.' );\n\n\t\t}\n\n\t\t// default options\n\t\toptions = Object.assign( {\n\n\t\t\t...DEFAULT_OPTIONS,\n\n\t\t\t// undocumented options\n\n\t\t\t// Whether to skip generating the tree. Used for deserialization.\n\t\t\t[ SKIP_GENERATION ]: false,\n\n\t\t}, options );\n\n\t\tif ( options.useSharedArrayBuffer && ! isSharedArrayBufferSupported() ) {\n\n\t\t\tthrow new Error( 'MeshBVH: SharedArrayBuffer is not available.' );\n\n\t\t}\n\n\t\t// retain references to the geometry so we can use them it without having to\n\t\t// take a geometry reference in every function.\n\t\tthis.geometry = geometry;\n\t\tthis._roots = null;\n\t\tthis._indirectBuffer = null;\n\t\tif ( ! options[ SKIP_GENERATION ] ) {\n\n\t\t\tbuildPackedTree( this, options );\n\n\t\t\tif ( ! geometry.boundingBox && options.setBoundingBox ) {\n\n\t\t\t\tgeometry.boundingBox = this.getBoundingBox( new Box3() );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.resolveTriangleIndex = options.indirect ? i => this._indirectBuffer[ i ] : i => i;\n\n\t}\n\n\trefit( nodeIndices = null ) {\n\n\t\tconst refitFunc = this.indirect ? refit_indirect : refit;\n\t\treturn refitFunc( this, nodeIndices );\n\n\t}\n\n\ttraverse( callback, rootIndex = 0 ) {\n\n\t\tconst buffer = this._roots[ rootIndex ];\n\t\tconst uint32Array = new Uint32Array( buffer );\n\t\tconst uint16Array = new Uint16Array( buffer );\n\t\t_traverse( 0 );\n\n\t\tfunction _traverse( node32Index, depth = 0 ) {\n\n\t\t\tconst node16Index = node32Index * 2;\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\t\t\t\tcallback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), offset, count );\n\n\t\t\t} else {\n\n\t\t\t\t// TODO: use node functions here\n\t\t\t\tconst left = node32Index + BYTES_PER_NODE / 4;\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst splitAxis = uint32Array[ node32Index + 7 ];\n\t\t\t\tconst stopTraversal = callback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), splitAxis );\n\n\t\t\t\tif ( ! stopTraversal ) {\n\n\t\t\t\t\t_traverse( left, depth + 1 );\n\t\t\t\t\t_traverse( right, depth + 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/* Core Cast Functions */\n\traycast( ray, materialOrSide = FrontSide, near = 0, far = Infinity ) {\n\n\t\tconst roots = this._roots;\n\t\tconst geometry = this.geometry;\n\t\tconst intersects = [];\n\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\tconst groups = geometry.groups;\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\tconst raycastFunc = this.indirect ? raycast_indirect : raycast;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\t\t\tconst startCount = intersects.length;\n\n\t\t\traycastFunc( this, i, materialSide, ray, intersects, near, far );\n\n\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\tconst materialIndex = groups[ i ].materialIndex;\n\t\t\t\tfor ( let j = startCount, jl = intersects.length; j < jl; j ++ ) {\n\n\t\t\t\t\tintersects[ j ].face.materialIndex = materialIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn intersects;\n\n\t}\n\n\traycastFirst( ray, materialOrSide = FrontSide, near = 0, far = Infinity ) {\n\n\t\tconst roots = this._roots;\n\t\tconst geometry = this.geometry;\n\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\tlet closestResult = null;\n\n\t\tconst groups = geometry.groups;\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\tconst raycastFirstFunc = this.indirect ? raycastFirst_indirect : raycastFirst;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\t\t\tconst result = raycastFirstFunc( this, i, materialSide, ray, near, far );\n\t\t\tif ( result != null && ( closestResult == null || result.distance < closestResult.distance ) ) {\n\n\t\t\t\tclosestResult = result;\n\t\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\t\tresult.face.materialIndex = groups[ i ].materialIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn closestResult;\n\n\t}\n\n\tintersectsGeometry( otherGeometry, geomToMesh ) {\n\n\t\tlet result = false;\n\t\tconst roots = this._roots;\n\t\tconst intersectsGeometryFunc = this.indirect ? intersectsGeometry_indirect : intersectsGeometry;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tresult = intersectsGeometryFunc( this, i, otherGeometry, geomToMesh );\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tshapecast( callbacks ) {\n\n\t\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\t\tconst iterateFunc = this.indirect ? iterateOverTriangles_indirect : iterateOverTriangles;\n\t\tlet {\n\t\t\tboundsTraverseOrder,\n\t\t\tintersectsBounds,\n\t\t\tintersectsRange,\n\t\t\tintersectsTriangle,\n\t\t} = callbacks;\n\n\t\t// wrap the intersectsRange function\n\t\tif ( intersectsRange && intersectsTriangle ) {\n\n\t\t\tconst originalIntersectsRange = intersectsRange;\n\t\t\tintersectsRange = ( offset, count, contained, depth, nodeIndex ) => {\n\n\t\t\t\tif ( ! originalIntersectsRange( offset, count, contained, depth, nodeIndex ) ) {\n\n\t\t\t\t\treturn iterateFunc( offset, count, this, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t};\n\n\t\t} else if ( ! intersectsRange ) {\n\n\t\t\tif ( intersectsTriangle ) {\n\n\t\t\t\tintersectsRange = ( offset, count, contained, depth ) => {\n\n\t\t\t\t\treturn iterateFunc( offset, count, this, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRange = ( offset, count, contained ) => {\n\n\t\t\t\t\treturn contained;\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\t// run shapecast\n\t\tlet result = false;\n\t\tlet byteOffset = 0;\n\t\tconst roots = this._roots;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst root = roots[ i ];\n\t\t\tresult = shapecast( this, i, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tbyteOffset += root.byteLength;\n\n\t\t}\n\n\t\tExtendedTrianglePool.releasePrimitive( triangle );\n\n\t\treturn result;\n\n\t}\n\n\tbvhcast( otherBvh, matrixToLocal, callbacks ) {\n\n\t\tlet {\n\t\t\tintersectsRanges,\n\t\t\tintersectsTriangles,\n\t\t} = callbacks;\n\n\t\tconst triangle1 = ExtendedTrianglePool.getPrimitive();\n\t\tconst indexAttr1 = this.geometry.index;\n\t\tconst positionAttr1 = this.geometry.attributes.position;\n\t\tconst assignTriangle1 = this.indirect ?\n\t\t\ti1 => {\n\n\n\t\t\t\tconst ti = this.resolveTriangleIndex( i1 );\n\t\t\t\tsetTriangle( triangle1, ti * 3, indexAttr1, positionAttr1 );\n\n\t\t\t} :\n\t\t\ti1 => {\n\n\t\t\t\tsetTriangle( triangle1, i1 * 3, indexAttr1, positionAttr1 );\n\n\t\t\t};\n\n\t\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\t\tconst indexAttr2 = otherBvh.geometry.index;\n\t\tconst positionAttr2 = otherBvh.geometry.attributes.position;\n\t\tconst assignTriangle2 = otherBvh.indirect ?\n\t\t\ti2 => {\n\n\t\t\t\tconst ti2 = otherBvh.resolveTriangleIndex( i2 );\n\t\t\t\tsetTriangle( triangle2, ti2 * 3, indexAttr2, positionAttr2 );\n\n\t\t\t} :\n\t\t\ti2 => {\n\n\t\t\t\tsetTriangle( triangle2, i2 * 3, indexAttr2, positionAttr2 );\n\n\t\t\t};\n\n\t\t// generate triangle callback if needed\n\t\tif ( intersectsTriangles ) {\n\n\t\t\tconst iterateOverDoubleTriangles = ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) => {\n\n\t\t\t\tfor ( let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\tassignTriangle2( i2 );\n\n\t\t\t\t\ttriangle2.a.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.b.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.c.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1 ++ ) {\n\n\t\t\t\t\t\tassignTriangle1( i1 );\n\n\t\t\t\t\t\ttriangle1.needsUpdate = true;\n\n\t\t\t\t\t\tif ( intersectsTriangles( triangle1, triangle2, i1, i2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t};\n\n\t\t\tif ( intersectsRanges ) {\n\n\t\t\t\tconst originalIntersectsRanges = intersectsRanges;\n\t\t\t\tintersectsRanges = function ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\n\n\t\t\t\t\tif ( ! originalIntersectsRanges( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\treturn iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRanges = iterateOverDoubleTriangles;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bvhcast( this, otherBvh, matrixToLocal, intersectsRanges );\n\n\t}\n\n\n\t/* Derived Cast Functions */\n\tintersectsBox( box, boxToMesh ) {\n\n\t\tobb.set( box.min, box.max, boxToMesh );\n\t\tobb.needsUpdate = true;\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => obb.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => obb.intersectsTriangle( tri )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => sphere.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => tri.intersectsSphere( sphere )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tclosestPointToGeometry( otherGeometry, geometryToBvh, target1 = { }, target2 = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\tconst closestPointToGeometryFunc = this.indirect ? closestPointToGeometry_indirect : closestPointToGeometry;\n\t\treturn closestPointToGeometryFunc(\n\t\t\tthis,\n\t\t\totherGeometry,\n\t\t\tgeometryToBvh,\n\t\t\ttarget1,\n\t\t\ttarget2,\n\t\t\tminThreshold,\n\t\t\tmaxThreshold,\n\t\t);\n\n\t}\n\n\tclosestPointToPoint( point, target = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\treturn closestPointToPoint(\n\t\t\tthis,\n\t\t\tpoint,\n\t\t\ttarget,\n\t\t\tminThreshold,\n\t\t\tmaxThreshold,\n\t\t);\n\n\t}\n\n\tgetBoundingBox( target ) {\n\n\t\ttarget.makeEmpty();\n\n\t\tconst roots = this._roots;\n\t\troots.forEach( buffer => {\n\n\t\t\tarrayToBox( 0, new Float32Array( buffer ), tempBox );\n\t\t\ttarget.union( tempBox );\n\n\t\t} );\n\n\t\treturn target;\n\n\t}\n\n}\n","import * as THREE from 'three';\nimport { shaderMaterial } from '../core/shaderMaterial.js';\nimport { shaderStructs, shaderIntersectFunction, MeshBVHUniformStruct } from 'three-mesh-bvh';\nimport { version } from '../helpers/constants.js';\n\n// Author: N8Programs\nconst MeshRefractionMaterial = /* @__PURE__ */shaderMaterial({\n  envMap: null,\n  bounces: 3,\n  ior: 2.4,\n  correctMips: true,\n  aberrationStrength: 0.01,\n  fresnel: 0,\n  bvh: /* @__PURE__ */new MeshBVHUniformStruct(),\n  color: /* @__PURE__ */new THREE.Color('white'),\n  opacity: 1,\n  resolution: /* @__PURE__ */new THREE.Vector2(),\n  viewMatrixInverse: /* @__PURE__ */new THREE.Matrix4(),\n  projectionMatrixInverse: /* @__PURE__ */new THREE.Matrix4()\n}, /*glsl*/`\n  uniform mat4 viewMatrixInverse;\n\n  varying vec3 vWorldPosition;\n  varying vec3 vNormal;\n  varying mat4 vModelMatrixInverse;\n\n  #include <color_pars_vertex>\n\n  void main() {\n    #include <color_vertex>\n\n    vec4 transformedNormal = vec4(normal, 0.0);\n    vec4 transformedPosition = vec4(position, 1.0);\n    #ifdef USE_INSTANCING\n      transformedNormal = instanceMatrix * transformedNormal;\n      transformedPosition = instanceMatrix * transformedPosition;\n    #endif\n\n    #ifdef USE_INSTANCING\n      vModelMatrixInverse = inverse(modelMatrix * instanceMatrix);\n    #else\n      vModelMatrixInverse = inverse(modelMatrix);\n    #endif\n\n    vWorldPosition = (modelMatrix * transformedPosition).xyz;\n    vNormal = normalize((viewMatrixInverse * vec4(normalMatrix * transformedNormal.xyz, 0.0)).xyz);\n    gl_Position = projectionMatrix * viewMatrix * modelMatrix * transformedPosition;\n  }`, /*glsl*/`\n  #define ENVMAP_TYPE_CUBE_UV\n  precision highp isampler2D;\n  precision highp usampler2D;\n  varying vec3 vWorldPosition;\n  varying vec3 vNormal;\n  varying mat4 vModelMatrixInverse;\n\n  #include <color_pars_fragment>\n\n  #ifdef ENVMAP_TYPE_CUBEM\n    uniform samplerCube envMap;\n  #else\n    uniform sampler2D envMap;\n  #endif\n\n  uniform float bounces;\n  ${shaderStructs}\n  ${shaderIntersectFunction}\n  uniform BVH bvh;\n  uniform float ior;\n  uniform bool correctMips;\n  uniform vec2 resolution;\n  uniform float fresnel;\n  uniform mat4 modelMatrix;\n  uniform mat4 projectionMatrixInverse;\n  uniform mat4 viewMatrixInverse;\n  uniform float aberrationStrength;\n  uniform vec3 color;\n  uniform float opacity;\n\n  float fresnelFunc(vec3 viewDirection, vec3 worldNormal) {\n    return pow( 1.0 + dot( viewDirection, worldNormal), 10.0 );\n  }\n\n  vec3 totalInternalReflection(vec3 ro, vec3 rd, vec3 normal, float ior, mat4 modelMatrixInverse) {\n    vec3 rayOrigin = ro;\n    vec3 rayDirection = rd;\n    rayDirection = refract(rayDirection, normal, 1.0 / ior);\n    rayOrigin = vWorldPosition + rayDirection * 0.001;\n    rayOrigin = (modelMatrixInverse * vec4(rayOrigin, 1.0)).xyz;\n    rayDirection = normalize((modelMatrixInverse * vec4(rayDirection, 0.0)).xyz);\n    for(float i = 0.0; i < bounces; i++) {\n      uvec4 faceIndices = uvec4( 0u );\n      vec3 faceNormal = vec3( 0.0, 0.0, 1.0 );\n      vec3 barycoord = vec3( 0.0 );\n      float side = 1.0;\n      float dist = 0.0;\n      bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist );\n      vec3 hitPos = rayOrigin + rayDirection * max(dist - 0.001, 0.0);\n      vec3 tempDir = refract(rayDirection, faceNormal, ior);\n      if (length(tempDir) != 0.0) {\n        rayDirection = tempDir;\n        break;\n      }\n      rayDirection = reflect(rayDirection, faceNormal);\n      rayOrigin = hitPos + rayDirection * 0.01;\n    }\n    rayDirection = normalize((modelMatrix * vec4(rayDirection, 0.0)).xyz);\n    return rayDirection;\n  }\n\n  #include <common>\n  #include <cube_uv_reflection_fragment>\n\n  #ifdef ENVMAP_TYPE_CUBEM\n    vec4 textureGradient(samplerCube envMap, vec3 rayDirection, vec3 directionCamPerfect) {\n      return textureGrad(envMap, rayDirection, dFdx(correctMips ? directionCamPerfect: rayDirection), dFdy(correctMips ? directionCamPerfect: rayDirection));\n    }\n  #else\n    vec4 textureGradient(sampler2D envMap, vec3 rayDirection, vec3 directionCamPerfect) {\n      vec2 uvv = equirectUv( rayDirection );\n      vec2 smoothUv = equirectUv( directionCamPerfect );\n      return textureGrad(envMap, uvv, dFdx(correctMips ? smoothUv : uvv), dFdy(correctMips ? smoothUv : uvv));\n    }\n  #endif\n\n  void main() {\n    vec2 uv = gl_FragCoord.xy / resolution;\n    vec3 directionCamPerfect = (projectionMatrixInverse * vec4(uv * 2.0 - 1.0, 0.0, 1.0)).xyz;\n    directionCamPerfect = (viewMatrixInverse * vec4(directionCamPerfect, 0.0)).xyz;\n    directionCamPerfect = normalize(directionCamPerfect);\n    vec3 normal = vNormal;\n    vec3 rayOrigin = cameraPosition;\n    vec3 rayDirection = normalize(vWorldPosition - cameraPosition);\n\n    vec4 diffuseColor = vec4(color, opacity);\n    #include <color_fragment>\n\n    #ifdef CHROMATIC_ABERRATIONS\n      vec3 rayDirectionG = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior, 1.0), vModelMatrixInverse);\n      #ifdef FAST_CHROMA\n        vec3 rayDirectionR = normalize(rayDirectionG + 1.0 * vec3(aberrationStrength / 2.0));\n        vec3 rayDirectionB = normalize(rayDirectionG - 1.0 * vec3(aberrationStrength / 2.0));\n      #else\n        vec3 rayDirectionR = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior * (1.0 - aberrationStrength), 1.0), vModelMatrixInverse);\n        vec3 rayDirectionB = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior * (1.0 + aberrationStrength), 1.0), vModelMatrixInverse);\n      #endif\n      float finalColorR = textureGradient(envMap, rayDirectionR, directionCamPerfect).r;\n      float finalColorG = textureGradient(envMap, rayDirectionG, directionCamPerfect).g;\n      float finalColorB = textureGradient(envMap, rayDirectionB, directionCamPerfect).b;\n      diffuseColor.rgb *= vec3(finalColorR, finalColorG, finalColorB);\n    #else\n      rayDirection = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior, 1.0), vModelMatrixInverse);\n      diffuseColor.rgb *= textureGradient(envMap, rayDirection, directionCamPerfect).rgb;\n    #endif\n\n    vec3 viewDirection = normalize(vWorldPosition - cameraPosition);\n    float nFresnel = fresnelFunc(viewDirection, normal) * fresnel;\n    gl_FragColor = vec4(mix(diffuseColor.rgb, vec3(1.0), nFresnel), diffuseColor.a);\n\n    #include <tonemapping_fragment>\n    #include <${version >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>\n  }`);\n\nexport { MeshRefractionMaterial };\n","// Note that a struct cannot be used for the hit record including faceIndices, faceNormal, barycoord,\n// side, and dist because on some mobile GPUS (such as Adreno) numbers are afforded less precision specifically\n// when in a struct leading to inaccurate hit results. See KhronosGroup/WebGL#3351 for more details.\nexport const bvh_struct_definitions = /* glsl */`\nstruct BVH {\n\n\tusampler2D index;\n\tsampler2D position;\n\n\tsampler2D bvhBounds;\n\tusampler2D bvhContents;\n\n};\n`;\n","// Distance to Point\nexport const bvh_distance_functions = /* glsl */`\n\nfloat dot2( vec3 v ) {\n\n\treturn dot( v, v );\n\n}\n\n// https://www.shadertoy.com/view/ttfGWl\nvec3 closestPointToTriangle( vec3 p, vec3 v0, vec3 v1, vec3 v2, out vec3 barycoord ) {\n\n    vec3 v10 = v1 - v0;\n    vec3 v21 = v2 - v1;\n    vec3 v02 = v0 - v2;\n\n\tvec3 p0 = p - v0;\n\tvec3 p1 = p - v1;\n\tvec3 p2 = p - v2;\n\n    vec3 nor = cross( v10, v02 );\n\n    // method 2, in barycentric space\n    vec3  q = cross( nor, p0 );\n    float d = 1.0 / dot2( nor );\n    float u = d * dot( q, v02 );\n    float v = d * dot( q, v10 );\n    float w = 1.0 - u - v;\n\n\tif( u < 0.0 ) {\n\n\t\tw = clamp( dot( p2, v02 ) / dot2( v02 ), 0.0, 1.0 );\n\t\tu = 0.0;\n\t\tv = 1.0 - w;\n\n\t} else if( v < 0.0 ) {\n\n\t\tu = clamp( dot( p0, v10 ) / dot2( v10 ), 0.0, 1.0 );\n\t\tv = 0.0;\n\t\tw = 1.0 - u;\n\n\t} else if( w < 0.0 ) {\n\n\t\tv = clamp( dot( p1, v21 ) / dot2( v21 ), 0.0, 1.0 );\n\t\tw = 0.0;\n\t\tu = 1.0-v;\n\n\t}\n\n\tbarycoord = vec3( u, v, w );\n    return u * v1 + v * v2 + w * v0;\n\n}\n\nfloat distanceToTriangles(\n\t// geometry info and triangle range\n\tsampler2D positionAttr, usampler2D indexAttr, uint offset, uint count,\n\n\t// point and cut off range\n\tvec3 point, float closestDistanceSquared,\n\n\t// outputs\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord, inout float side, inout vec3 outPoint\n) {\n\n\tbool found = false;\n\tvec3 localBarycoord;\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\tuvec3 indices = uTexelFetch1D( indexAttr, i ).xyz;\n\t\tvec3 a = texelFetch1D( positionAttr, indices.x ).rgb;\n\t\tvec3 b = texelFetch1D( positionAttr, indices.y ).rgb;\n\t\tvec3 c = texelFetch1D( positionAttr, indices.z ).rgb;\n\n\t\t// get the closest point and barycoord\n\t\tvec3 closestPoint = closestPointToTriangle( point, a, b, c, localBarycoord );\n\t\tvec3 delta = point - closestPoint;\n\t\tfloat sqDist = dot2( delta );\n\t\tif ( sqDist < closestDistanceSquared ) {\n\n\t\t\t// set the output results\n\t\t\tclosestDistanceSquared = sqDist;\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\n\t\t\tfaceNormal = normalize( cross( a - b, b - c ) );\n\t\t\tbarycoord = localBarycoord;\n\t\t\toutPoint = closestPoint;\n\t\t\tside = sign( dot( faceNormal, delta ) );\n\n\t\t}\n\n\t}\n\n\treturn closestDistanceSquared;\n\n}\n\nfloat distanceSqToBounds( vec3 point, vec3 boundsMin, vec3 boundsMax ) {\n\n\tvec3 clampedPoint = clamp( point, boundsMin, boundsMax );\n\tvec3 delta = point - clampedPoint;\n\treturn dot( delta, delta );\n\n}\n\nfloat distanceSqToBVHNodeBoundsPoint( vec3 point, sampler2D bvhBounds, uint currNodeIndex ) {\n\n\tuint cni2 = currNodeIndex * 2u;\n\tvec3 boundsMin = texelFetch1D( bvhBounds, cni2 ).xyz;\n\tvec3 boundsMax = texelFetch1D( bvhBounds, cni2 + 1u ).xyz;\n\treturn distanceSqToBounds( point, boundsMin, boundsMax );\n\n}\n\n// use a macro to hide the fact that we need to expand the struct into separate fields\n#define\\\n\tbvhClosestPointToPoint(\\\n\t\tbvh,\\\n\t\tpoint, faceIndices, faceNormal, barycoord, side, outPoint\\\n\t)\\\n\t_bvhClosestPointToPoint(\\\n\t\tbvh.position, bvh.index, bvh.bvhBounds, bvh.bvhContents,\\\n\t\tpoint, faceIndices, faceNormal, barycoord, side, outPoint\\\n\t)\n\nfloat _bvhClosestPointToPoint(\n\t// bvh info\n\tsampler2D bvh_position, usampler2D bvh_index, sampler2D bvh_bvhBounds, usampler2D bvh_bvhContents,\n\n\t// point to check\n\tvec3 point,\n\n\t// output variables\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout vec3 outPoint\n ) {\n\n\t// stack needs to be twice as long as the deepest tree we expect because\n\t// we push both the left and right child onto the stack every traversal\n\tint ptr = 0;\n\tuint stack[ BVH_STACK_DEPTH ];\n\tstack[ 0 ] = 0u;\n\n\tfloat closestDistanceSquared = pow( 100000.0, 2.0 );\n\tbool found = false;\n\twhile ( ptr > - 1 && ptr < BVH_STACK_DEPTH ) {\n\n\t\tuint currNodeIndex = stack[ ptr ];\n\t\tptr --;\n\n\t\t// check if we intersect the current bounds\n\t\tfloat boundsHitDistance = distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, currNodeIndex );\n\t\tif ( boundsHitDistance > closestDistanceSquared ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh_bvhContents, currNodeIndex ).xy;\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\n\t\tif ( isLeaf ) {\n\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint offset = boundsInfo.y;\n\t\t\tclosestDistanceSquared = distanceToTriangles(\n\t\t\t\tbvh_position, bvh_index, offset, count, point, closestDistanceSquared,\n\n\t\t\t\t// outputs\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, outPoint\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tuint leftIndex = currNodeIndex + 1u;\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint rightIndex = boundsInfo.y;\n\t\t\tbool leftToRight = distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, leftIndex ) < distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, rightIndex );//rayDirection[ splitAxis ] >= 0.0;\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\n\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\n\t\t\t// traversed first\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c2;\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c1;\n\n\t\t}\n\n\t}\n\n\treturn sqrt( closestDistanceSquared );\n\n}\n`;\n","export const common_functions = /* glsl */`\n\n// A stack of uint32 indices can can store the indices for\n// a perfectly balanced tree with a depth up to 31. Lower stack\n// depth gets higher performance.\n//\n// However not all trees are balanced. Best value to set this to\n// is the trees max depth.\n#ifndef BVH_STACK_DEPTH\n#define BVH_STACK_DEPTH 60\n#endif\n\n#ifndef INFINITY\n#define INFINITY 1e20\n#endif\n\n// Utilities\nuvec4 uTexelFetch1D( usampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nivec4 iTexelFetch1D( isampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 texelFetch1D( sampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 textureSampleBarycoord( sampler2D tex, vec3 barycoord, uvec3 faceIndices ) {\n\n\treturn\n\t\tbarycoord.x * texelFetch1D( tex, faceIndices.x ) +\n\t\tbarycoord.y * texelFetch1D( tex, faceIndices.y ) +\n\t\tbarycoord.z * texelFetch1D( tex, faceIndices.z );\n\n}\n\nvoid ndcToCameraRay(\n\tvec2 coord, mat4 cameraWorld, mat4 invProjectionMatrix,\n\tout vec3 rayOrigin, out vec3 rayDirection\n) {\n\n\t// get camera look direction and near plane for camera clipping\n\tvec4 lookDirection = cameraWorld * vec4( 0.0, 0.0, - 1.0, 0.0 );\n\tvec4 nearVector = invProjectionMatrix * vec4( 0.0, 0.0, - 1.0, 1.0 );\n\tfloat near = abs( nearVector.z / nearVector.w );\n\n\t// get the camera direction and position from camera matrices\n\tvec4 origin = cameraWorld * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec4 direction = invProjectionMatrix * vec4( coord, 0.5, 1.0 );\n\tdirection /= direction.w;\n\tdirection = cameraWorld * direction - origin;\n\n\t// slide the origin along the ray until it sits at the near clip plane position\n\torigin.xyz += direction.xyz * near / dot( direction, lookDirection );\n\n\trayOrigin = origin.xyz;\n\trayDirection = direction.xyz;\n\n}\n`;\n","export const bvh_ray_functions = /* glsl */`\n\n#ifndef TRI_INTERSECT_EPSILON\n#define TRI_INTERSECT_EPSILON 1e-5\n#endif\n\n// Raycasting\nbool intersectsBounds( vec3 rayOrigin, vec3 rayDirection, vec3 boundsMin, vec3 boundsMax, out float dist ) {\n\n\t// https://www.reddit.com/r/opengl/comments/8ntzz5/fast_glsl_ray_box_intersection/\n\t// https://tavianator.com/2011/ray_box.html\n\tvec3 invDir = 1.0 / rayDirection;\n\n\t// find intersection distances for each plane\n\tvec3 tMinPlane = invDir * ( boundsMin - rayOrigin );\n\tvec3 tMaxPlane = invDir * ( boundsMax - rayOrigin );\n\n\t// get the min and max distances from each intersection\n\tvec3 tMinHit = min( tMaxPlane, tMinPlane );\n\tvec3 tMaxHit = max( tMaxPlane, tMinPlane );\n\n\t// get the furthest hit distance\n\tvec2 t = max( tMinHit.xx, tMinHit.yz );\n\tfloat t0 = max( t.x, t.y );\n\n\t// get the minimum hit distance\n\tt = min( tMaxHit.xx, tMaxHit.yz );\n\tfloat t1 = min( t.x, t.y );\n\n\t// set distance to 0.0 if the ray starts inside the box\n\tdist = max( t0, 0.0 );\n\n\treturn t1 >= dist;\n\n}\n\nbool intersectsTriangle(\n\tvec3 rayOrigin, vec3 rayDirection, vec3 a, vec3 b, vec3 c,\n\tout vec3 barycoord, out vec3 norm, out float dist, out float side\n) {\n\n\t// https://stackoverflow.com/questions/42740765/intersection-between-line-and-triangle-in-3d\n\tvec3 edge1 = b - a;\n\tvec3 edge2 = c - a;\n\tnorm = cross( edge1, edge2 );\n\n\tfloat det = - dot( rayDirection, norm );\n\tfloat invdet = 1.0 / det;\n\n\tvec3 AO = rayOrigin - a;\n\tvec3 DAO = cross( AO, rayDirection );\n\n\tvec4 uvt;\n\tuvt.x = dot( edge2, DAO ) * invdet;\n\tuvt.y = - dot( edge1, DAO ) * invdet;\n\tuvt.z = dot( AO, norm ) * invdet;\n\tuvt.w = 1.0 - uvt.x - uvt.y;\n\n\t// set the hit information\n\tbarycoord = uvt.wxy; // arranged in A, B, C order\n\tdist = uvt.z;\n\tside = sign( det );\n\tnorm = side * normalize( norm );\n\n\t// add an epsilon to avoid misses between triangles\n\tuvt += vec4( TRI_INTERSECT_EPSILON );\n\n\treturn all( greaterThanEqual( uvt, vec4( 0.0 ) ) );\n\n}\n\nbool intersectTriangles(\n\t// geometry info and triangle range\n\tsampler2D positionAttr, usampler2D indexAttr, uint offset, uint count,\n\n\t// ray\n\tvec3 rayOrigin, vec3 rayDirection,\n\n\t// outputs\n\tinout float minDistance, inout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout float dist\n) {\n\n\tbool found = false;\n\tvec3 localBarycoord, localNormal;\n\tfloat localDist, localSide;\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\tuvec3 indices = uTexelFetch1D( indexAttr, i ).xyz;\n\t\tvec3 a = texelFetch1D( positionAttr, indices.x ).rgb;\n\t\tvec3 b = texelFetch1D( positionAttr, indices.y ).rgb;\n\t\tvec3 c = texelFetch1D( positionAttr, indices.z ).rgb;\n\n\t\tif (\n\t\t\tintersectsTriangle( rayOrigin, rayDirection, a, b, c, localBarycoord, localNormal, localDist, localSide )\n\t\t\t&& localDist < minDistance\n\t\t) {\n\n\t\t\tfound = true;\n\t\t\tminDistance = localDist;\n\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\n\t\t\tfaceNormal = localNormal;\n\n\t\t\tside = localSide;\n\t\t\tbarycoord = localBarycoord;\n\t\t\tdist = localDist;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n\nbool intersectsBVHNodeBounds( vec3 rayOrigin, vec3 rayDirection, sampler2D bvhBounds, uint currNodeIndex, out float dist ) {\n\n\tuint cni2 = currNodeIndex * 2u;\n\tvec3 boundsMin = texelFetch1D( bvhBounds, cni2 ).xyz;\n\tvec3 boundsMax = texelFetch1D( bvhBounds, cni2 + 1u ).xyz;\n\treturn intersectsBounds( rayOrigin, rayDirection, boundsMin, boundsMax, dist );\n\n}\n\n// use a macro to hide the fact that we need to expand the struct into separate fields\n#define\\\n\tbvhIntersectFirstHit(\\\n\t\tbvh,\\\n\t\trayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist\\\n\t)\\\n\t_bvhIntersectFirstHit(\\\n\t\tbvh.position, bvh.index, bvh.bvhBounds, bvh.bvhContents,\\\n\t\trayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist\\\n\t)\n\nbool _bvhIntersectFirstHit(\n\t// bvh info\n\tsampler2D bvh_position, usampler2D bvh_index, sampler2D bvh_bvhBounds, usampler2D bvh_bvhContents,\n\n\t// ray\n\tvec3 rayOrigin, vec3 rayDirection,\n\n\t// output variables split into separate variables due to output precision\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout float dist\n) {\n\n\t// stack needs to be twice as long as the deepest tree we expect because\n\t// we push both the left and right child onto the stack every traversal\n\tint ptr = 0;\n\tuint stack[ BVH_STACK_DEPTH ];\n\tstack[ 0 ] = 0u;\n\n\tfloat triangleDistance = INFINITY;\n\tbool found = false;\n\twhile ( ptr > - 1 && ptr < BVH_STACK_DEPTH ) {\n\n\t\tuint currNodeIndex = stack[ ptr ];\n\t\tptr --;\n\n\t\t// check if we intersect the current bounds\n\t\tfloat boundsHitDistance;\n\t\tif (\n\t\t\t! intersectsBVHNodeBounds( rayOrigin, rayDirection, bvh_bvhBounds, currNodeIndex, boundsHitDistance )\n\t\t\t|| boundsHitDistance > triangleDistance\n\t\t) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh_bvhContents, currNodeIndex ).xy;\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\n\n\t\tif ( isLeaf ) {\n\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint offset = boundsInfo.y;\n\n\t\t\tfound = intersectTriangles(\n\t\t\t\tbvh_position, bvh_index, offset, count,\n\t\t\t\trayOrigin, rayDirection, triangleDistance,\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, dist\n\t\t\t) || found;\n\n\t\t} else {\n\n\t\t\tuint leftIndex = currNodeIndex + 1u;\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint rightIndex = boundsInfo.y;\n\n\t\t\tbool leftToRight = rayDirection[ splitAxis ] >= 0.0;\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\n\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\n\t\t\t// traversed first\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c2;\n\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c1;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n`;\n","export { MeshBVH } from './core/MeshBVH.js';\nexport { MeshBVHHelper } from './objects/MeshBVHHelper.js';\nexport { CENTER, AVERAGE, SAH, NOT_INTERSECTED, INTERSECTED, CONTAINED } from './core/Constants.js';\nexport { getBVHExtremes, estimateMemoryInBytes, getJSONStructure, validateBounds } from './debug/Debug.js';\nexport * from './utils/ExtensionUtilities.js';\nexport { getTriangleHitPointInfo } from './utils/TriangleUtilities.js';\nexport * from './math/ExtendedTriangle.js';\nexport * from './math/OrientedBox.js';\nexport * from './gpu/MeshBVHUniformStruct.js';\nexport * from './gpu/VertexAttributeTexture.js';\nexport * from './utils/StaticGeometryGenerator.js';\nexport * as BVHShaderGLSL from './gpu/BVHShaderGLSL.js';\n\n// backwards compatibility\nimport * as BVHShaderGLSL from './gpu/BVHShaderGLSL.js';\nexport const shaderStructs = BVHShaderGLSL.bvh_struct_definitions;\nexport const shaderDistanceFunction = BVHShaderGLSL.bvh_distance_functions;\nexport const shaderIntersectFunction = `\n\t${ BVHShaderGLSL.common_functions }\n\t${ BVHShaderGLSL.bvh_ray_functions }\n`;\n"],"names":[],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46]}